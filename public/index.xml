<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>爱吃芒果</title>
        <link>http://example.org/</link>
        <description>This is my cool site</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 25 Jan 2026 21:37:20 &#43;0800</lastBuildDate>
            <atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>Presto任务执行流程</title>
    <link>http://example.org/posts/presto-task-execution/</link>
    <pubDate>Sun, 25 Jan 2026 21:37:20 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-task-execution/</guid>
    <description><![CDATA[<div class="code-block code-line-numbers" style="counter-reset: code-block 0">
    <div class="code-header language-java">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// TaskResouce /v1/task/{taskId}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">Response</span><span class="w"> </span><span class="nf">createOrUpdateTask</span><span class="p">(</span><span class="nd">@PathParam</span><span class="p">(</span><span class="s">&#34;taskId&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">TaskId</span><span class="w"> </span><span class="n">taskId</span><span class="p">,</span><span class="w"> </span><span class="n">TaskUpdateRequest</span><span class="w"> </span><span class="n">taskUpdateRequest</span><span class="p">,</span><span class="w"> </span><span class="nd">@Context</span><span class="w"> </span><span class="n">UriInfo</span><span class="w"> </span><span class="n">uriInfo</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">requireNonNull</span><span class="p">(</span><span class="n">taskUpdateRequest</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;taskUpdateRequest is null&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Session</span><span class="w"> </span><span class="n">session</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskUpdateRequest</span><span class="p">.</span><span class="na">getSession</span><span class="p">().</span><span class="na">toSession</span><span class="p">(</span><span class="n">sessionPropertyManager</span><span class="p">,</span><span class="w"> </span><span class="n">taskUpdateRequest</span><span class="p">.</span><span class="na">getExtraCredentials</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">TaskInfo</span><span class="w"> </span><span class="n">taskInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskManager</span><span class="p">.</span><span class="na">updateTask</span><span class="p">(</span><span class="n">session</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">taskId</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">taskUpdateRequest</span><span class="p">.</span><span class="na">getFragment</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">taskUpdateRequest</span><span class="p">.</span><span class="na">getSources</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">taskUpdateRequest</span><span class="p">.</span><span class="na">getOutputIds</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">taskUpdateRequest</span><span class="p">.</span><span class="na">getTotalPartitions</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shouldSummarize</span><span class="p">(</span><span class="n">uriInfo</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskInfo</span><span class="p">.</span><span class="na">summarize</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Response</span><span class="p">.</span><span class="na">ok</span><span class="p">().</span><span class="na">entity</span><span class="p">(</span><span class="n">taskInfo</span><span class="p">).</span><span class="na">build</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
<item>
    <title>Presto客户端和服务区交互流程</title>
    <link>http://example.org/posts/presto-client-server-interaction/</link>
    <pubDate>Sun, 25 Jan 2026 21:34:59 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-client-server-interaction/</guid>
    <description><![CDATA[<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-java">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">StatementClientV1</span><span class="p">.</span><span class="na">advance</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">ExecutingStatementResource</span><span class="p">::</span><span class="n">getQueryResult</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nl">Query</span><span class="p">::</span><span class="n">getNextResult</span></span></span></code></pre></div></div>]]></description>
</item>
<item>
    <title>Presto执行计划的调度</title>
    <link>http://example.org/posts/presto-query-schedule-task/</link>
    <pubDate>Sun, 25 Jan 2026 14:05:02 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-query-schedule-task/</guid>
    <description><![CDATA[<p>在Presto的执行模型中，SQL的执行被划分为如下几个层次：</p>
<ul>
<li>查询：用户提交一个SQL，触发Presto的一次查询，在代码中对应一个QueryInfo。每个查询都有一个字符串形式的QueryId</li>
<li>查询执行阶段：Presto生成查询的执行计划时，根据是否需要做跨查询执行节点的数据交换来划分PlanFragment。调度执行计划时，每个PlanFragment对应一个查询执行阶段，在代码中对应一个StageInfo，其中有StageId，StageId的形式为QueryId + 从0自增id。查询执行阶段之间有数据依赖关系，即不能并行执行，存在执行上的顺序关系，需要注意的是，StageId越小，这个查询执行阶段的执行顺序越靠后。Presto的查询执行阶段类似于Spark的查询执行阶段的概念，他们的不同是Presto不像Spark批式处理那样，需要前面的查询执行阶段执行完再执行后面的查询执行阶段，Presto采用的是流水线（Pipeline）处理机制。</li>
<li>任务（Task）：任务是Presto分布式任务的执行单元，每个查询执行阶段可以有多个任务，这些任务可以并行执行，同一个查询执行阶段中的所有任务的执行逻辑完全相同。一个查询执行阶段的任务个数就是此查询执行阶段的并发度。在Presto的任务调度代码中，可以看到任务的个数是根据查询执行阶段的数据分布方式（Source，Fixed，Single）以及查询执行节点的个数来决定的。</li>
</ul>
<div class="code-block code-line-numbers" style="counter-reset: code-block 0">
    <div class="code-header language-java">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// SqlQueryExecution.java</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">planDistribution</span><span class="p">(</span><span class="n">PlanRoot</span><span class="w"> </span><span class="n">plan</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  	</span><span class="c1">// 遍历执行计划PlanNode树，找到所有的TableScanNode（也就是连接器对应的PlanNode），获取到他们的SplitSource</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">DistributedExecutionPlanner</span><span class="w"> </span><span class="n">distributedPlanner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DistributedExecutionPlanner</span><span class="p">(</span><span class="n">splitManager</span><span class="p">,</span><span class="w"> </span><span class="n">metadata</span><span class="p">,</span><span class="w"> </span><span class="n">dynamicFilterService</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">StageExecutionPlan</span><span class="w"> </span><span class="n">outputStageExecutionPlan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distributedPlanner</span><span class="p">.</span><span class="na">plan</span><span class="p">(</span><span class="n">plan</span><span class="p">.</span><span class="na">getRoot</span><span class="p">(),</span><span class="w"> </span><span class="n">stateMachine</span><span class="p">.</span><span class="na">getSession</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  	</span><span class="c1">// 创建最后一个查询执行阶段的Outputbuffer，这个OutputBuffer用于给Presto SQL客户端输出查询的最终计算结果</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">PartitioningHandle</span><span class="w"> </span><span class="n">partitioningHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plan</span><span class="p">.</span><span class="na">getRoot</span><span class="p">().</span><span class="na">getFragment</span><span class="p">().</span><span class="na">getPartitioningScheme</span><span class="p">().</span><span class="na">getPartitioning</span><span class="p">().</span><span class="na">getHandle</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">OutputBuffers</span><span class="w"> </span><span class="n">rootOutputBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createInitialEmptyOutputBuffers</span><span class="p">(</span><span class="n">partitioningHandle</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">withBuffer</span><span class="p">(</span><span class="n">OUTPUT_BUFFER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">BROADCAST_PARTITION_ID</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">withNoMoreBufferIds</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 创建SqlStageExecution，并将其封装在SqlQueryScheduler里面返回</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  	</span><span class="c1">// 这里只是创建Stage，但是不会去调度执行它</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">SqlQueryScheduler</span><span class="w"> </span><span class="n">scheduler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createSqlQueryScheduler</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">stateMachine</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">outputStageExecutionPlan</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">nodePartitioningManager</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">nodeScheduler</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">remoteTaskFactory</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">stateMachine</span><span class="p">.</span><span class="na">getSession</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">plan</span><span class="p">.</span><span class="na">isSummarizeTaskInfos</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">scheduleSplitBatchSize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">queryExecutor</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">schedulerExecutor</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">failureDetector</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">rootOutputBuffers</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">nodeTaskMap</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executionPolicy</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">schedulerStats</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">dynamicFilterService</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">queryScheduler</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">scheduler</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div></div>
<h3 id="获取数据源分片">获取数据源分片</h3>
<p><code>SqlQueryExecution.planDistribution</code>首先从数据源连接器中获取到所有的分片数据源。分片是Presto中分块组织数据的方式，Presto连接器会将待处理的所有数据划分为若干分片让Presto读取，而这些分片也会被安排到多个Presto查询执行节点上来处理以实现分布式高性能计算。分布式OLAP引擎几乎全都有分片的抽象设计，例如Spark、Flink等。</p>]]></description>
</item>
<item>
    <title>Presto查询计划生成和优化</title>
    <link>http://example.org/posts/presto-query-plan/</link>
    <pubDate>Sat, 24 Jan 2026 19:35:06 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-query-plan/</guid>
    <description><![CDATA[<p>在<code>SqlQueryExecution.doPlanQuery</code>中，从原来的抽象语法树生成逻辑执行计划，然后优化执行计划，生成优化后的执行计划，最后将逻辑执行计划切分成多颗子树。</p>]]></description>
</item>
<item>
    <title>Presto环境搭建</title>
    <link>http://example.org/posts/presto-environment-setup/</link>
    <pubDate>Sat, 17 Jan 2026 15:11:35 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-environment-setup/</guid>
    <description><![CDATA[<h2 id="前言">前言</h2>
<p>Trino是从Presto分离出来的项目，在后面的文章中不会严格区分Presto和Trino，除非某些代码只在其中一个项目中存在，根据《OLAP引擎底层原理与设计实践》的推荐，后面基本会通过trino项目的v350版本为例分析presto的一些源码级的实现，希望能够比较系统地理解OLAP引擎的整体实现。</p>]]></description>
</item>
<item>
    <title>Presto worker高负载查杀任务</title>
    <link>http://example.org/posts/presto-high-memory-task-killer/</link>
    <pubDate>Wed, 14 Jan 2026 16:26:01 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-high-memory-task-killer/</guid>
    <description><![CDATA[<p>为了尽量避免worker发生OOM从而短暂不可用，Presto提供了在内存高负载下查杀任务的机制，代码很简单，在<code>com.facebook.presto.memory.HighMemoryTaskKiller</code>中。</p>]]></description>
</item>
<item>
    <title>Grpc Keepalive</title>
    <link>http://example.org/posts/grpc-keepalive/</link>
    <pubDate>Sun, 19 Oct 2025 09:08:02 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/grpc-keepalive/</guid>
    <description><![CDATA[<h2 id="tcp-keepalive">TCP KeepAlive</h2>
<p><a href="https://www.cnblogs.com/hueyxu/p/15759819.html" target="_blank" rel="noopener noreffer ">TCP KeepAlive机制理解与实践小结</a>中详细介绍了TCP KeepAlive的机制，这里重点提一下涉及到的参数:</p>
<ul>
<li><code>tcp_keepalive_time</code> 在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的空闲时长，默认为2h</li>
<li><code>tcp_keepalive_probes</code> 最大允许发送保活探测包的次数，达到此次数后直接放弃尝试，并关闭连接，默认为9次</li>
<li><code>tcp_keepalive_intvl</code> 发送保活探测包的间隔，默认为75s</li>
</ul>
<p>所以如果开启了TCP KeepAlive并保持默认参数，则空闲连接会在大约 2h 11min之后被断开</p>]]></description>
</item>
<item>
    <title>Grpc Client Connection</title>
    <link>http://example.org/posts/grpc-client-connection/</link>
    <pubDate>Sun, 12 Oct 2025 16:55:50 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/grpc-client-connection/</guid>
    <description><![CDATA[<p></p>
<p></p>
<p></p>
<p>是的，有不少优秀的博客／技术文章探讨了在 gRPC / TCP 长连接中，应对“隐蔽断开”（silent drop）、“僵尸连接”（zombie connection）问题的方案。下面列几个经典与实用的，并且我还会摘关键要点供你快速对比。</p>]]></description>
</item>
<item>
    <title>直接内存实战</title>
    <link>http://example.org/posts/direct-memory-in-practice/</link>
    <pubDate>Sun, 07 Sep 2025 14:04:12 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/direct-memory-in-practice/</guid>
    <description><![CDATA[<h2 id="背景知识">背景知识</h2>
<p>在JDK 1.2之后，Java将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phanom Reference），这4种引用强度依次逐渐减弱。</p>]]></description>
</item>
<item>
    <title>gRPC元数据</title>
    <link>http://example.org/posts/grpc-metadata/</link>
    <pubDate>Sat, 02 Aug 2025 17:15:19 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/grpc-metadata/</guid>
    <description><![CDATA[<p>Metadata是关于某个特定RPC调用的信息，grpc元数据通过HTTP/2 header实现，它以键值对的形式存在，其中键是字符串，值通常是字符串，但也可以是二进制数据。键不区分大小写，由ASCII字母、数字和特殊字符<code>-</code>、<code>_</code>、<code>.</code>组成，但不能以<code>grpc-</code>开头（该前缀保留给gRPC使用），二进制数据对应的key以<code>-bin</code>结尾，而ASCII类型的键不带<code>-bin</code>后缀。</p>]]></description>
</item>
</channel>
</rss>
