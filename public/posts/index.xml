<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - 爱吃芒果</title>
        <link>http://example.org/posts/</link>
        <description>All Posts | 爱吃芒果</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 17 Jan 2026 15:11:35 &#43;0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Presto环境搭建</title>
    <link>http://example.org/posts/presto-environment-setup/</link>
    <pubDate>Sat, 17 Jan 2026 15:11:35 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-environment-setup/</guid>
    <description><![CDATA[<h2 id="前言">前言</h2>
<p>Trino是从Presto分离出来的项目，在后面的文章中不会严格区分Presto和Trino，除非某些代码只在其中一个项目中存在，根据《OLAP引擎底层原理与设计实践》的推荐，后面基本会通过trino项目的v350版本为例分析presto的一些源码级的实现，希望能够比较系统地理解OLAP引擎的整体实现。</p>]]></description>
</item>
<item>
    <title>Presto worker高负载查杀任务</title>
    <link>http://example.org/posts/presto-high-memory-task-killer/</link>
    <pubDate>Wed, 14 Jan 2026 16:26:01 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/presto-high-memory-task-killer/</guid>
    <description><![CDATA[<p>为了尽量避免worker发生OOM从而短暂不可用，Presto提供了在内存高负载下查杀任务的机制，代码很简单，在<code>com.facebook.presto.memory.HighMemoryTaskKiller</code>中。</p>]]></description>
</item>
<item>
    <title>Grpc Keepalive</title>
    <link>http://example.org/posts/grpc-keepalive/</link>
    <pubDate>Sun, 19 Oct 2025 09:08:02 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/grpc-keepalive/</guid>
    <description><![CDATA[<h2 id="tcp-keepalive">TCP KeepAlive</h2>
<p><a href="https://www.cnblogs.com/hueyxu/p/15759819.html" target="_blank" rel="noopener noreffer ">TCP KeepAlive机制理解与实践小结</a>中详细介绍了TCP KeepAlive的机制，这里重点提一下涉及到的参数:</p>
<ul>
<li><code>tcp_keepalive_time</code> 在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的空闲时长，默认为2h</li>
<li><code>tcp_keepalive_probes</code> 最大允许发送保活探测包的次数，达到此次数后直接放弃尝试，并关闭连接，默认为9次</li>
<li><code>tcp_keepalive_intvl</code> 发送保活探测包的间隔，默认为75s</li>
</ul>
<p>所以如果开启了TCP KeepAlive并保持默认参数，则空闲连接会在大约 2h 11min之后被断开</p>]]></description>
</item>
<item>
    <title>Grpc Client Connection</title>
    <link>http://example.org/posts/grpc-client-connection/</link>
    <pubDate>Sun, 12 Oct 2025 16:55:50 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/grpc-client-connection/</guid>
    <description><![CDATA[<p></p>
<p></p>
<p></p>
<p>是的，有不少优秀的博客／技术文章探讨了在 gRPC / TCP 长连接中，应对“隐蔽断开”（silent drop）、“僵尸连接”（zombie connection）问题的方案。下面列几个经典与实用的，并且我还会摘关键要点供你快速对比。</p>]]></description>
</item>
<item>
    <title>直接内存实战</title>
    <link>http://example.org/posts/direct-memory-in-practice/</link>
    <pubDate>Sun, 07 Sep 2025 14:04:12 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/direct-memory-in-practice/</guid>
    <description><![CDATA[<h2 id="背景知识">背景知识</h2>
<p>在JDK 1.2之后，Java将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phanom Reference），这4种引用强度依次逐渐减弱。</p>]]></description>
</item>
<item>
    <title>gRPC元数据</title>
    <link>http://example.org/posts/grpc-metadata/</link>
    <pubDate>Sat, 02 Aug 2025 17:15:19 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/grpc-metadata/</guid>
    <description><![CDATA[<p>Metadata是关于某个特定RPC调用的信息，grpc元数据通过HTTP/2 header实现，它以键值对的形式存在，其中键是字符串，值通常是字符串，但也可以是二进制数据。键不区分大小写，由ASCII字母、数字和特殊字符<code>-</code>、<code>_</code>、<code>.</code>组成，但不能以<code>grpc-</code>开头（该前缀保留给gRPC使用），二进制数据对应的key以<code>-bin</code>结尾，而ASCII类型的键不带<code>-bin</code>后缀。</p>]]></description>
</item>
<item>
    <title>grpc拦截器</title>
    <link>http://example.org/posts/grpc-interceptors/</link>
    <pubDate>Sat, 02 Aug 2025 15:03:09 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/grpc-interceptors/</guid>
    <description><![CDATA[]]></description>
</item>
<item>
    <title>FoundationDB in Practice</title>
    <link>http://example.org/posts/foundationdb-in-practice/</link>
    <pubDate>Sat, 26 Jul 2025 17:05:57 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/foundationdb-in-practice/</guid>
    <description><![CDATA[<h2 id="mac上运行foundationdb">mac上运行FoundationDB</h2>
<p>fdb_java的java包没有打包fdb_c的动态链接库，所以需要通过<code>-DFDB_LIBRARY_PATH_FDB_C=/usr/local/lib/libfdb_c.dylib</code>指定对应的动态链接库位置。</p>]]></description>
</item>
<item>
    <title>Java日志实战</title>
    <link>http://example.org/posts/java-log-in-practice/</link>
    <pubDate>Tue, 22 Jul 2025 14:42:40 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/java-log-in-practice/</guid>
    <description><![CDATA[<p>主要其实是学习<a href="https://mp.weixin.qq.com/s/eIiu08fVk194E0BgGL5gow" target="_blank" rel="noopener noreffer ">Java日志通关</a>系列文章，大佬太强了</p>
<p></p>
<p>日志发展到今天，被抽象成了三层，接口层、实现层、适配层。</p>
<ul>
<li>接口层：或者叫日志门面（facade），就是interface，只定义接口，等别人实现</li>
<li>实现层：真正干活的，能够把日志内存记录下来的工具，但请注意它不是上面接口实现，因为它不感知也不直接实现接口，仅仅是独立的实现</li>
<li>适配层：一般称为adapter，因为接口层和适配层并非都出自一家之手，它们之间无法直接匹配</li>
</ul>
<p>适配层有可以分为绑定（binding）和桥接（bridging）两种能力：</p>]]></description>
</item>
<item>
    <title>Presto数据过滤和投影</title>
    <link>http://example.org/posts/trino-filter-project/</link>
    <pubDate>Sun, 20 Jul 2025 09:12:14 &#43;0800</pubDate>
    <author>爱吃芒果</author>
    <guid>http://example.org/posts/trino-filter-project/</guid>
    <description><![CDATA[<h2 id="简单拉取数据查询的实现原理">简单拉取数据查询的实现原理</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-sql">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">ss_item_sk</span><span class="p">,</span><span class="w"> </span><span class="n">ss_sales_price</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">store_sales</span><span class="p">;</span></span></span></code></pre></div></div>
<h3 id="执行计划的生成和优化">执行计划的生成和优化</h3>
<h4 id="初始逻辑执行计划">初始逻辑执行计划</h4>
<div class="mermaid" id="id-1"></div><p>TableScan节点：负责从数据源连接器拉取数据</p>
<p>Output节点：逻辑执行计划的根节点，表示输出计算结果，其自身没有计算逻辑</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-java">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TableScanNode</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">extends</span><span class="w"> </span><span class="n">PlanNode</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  	</span><span class="c1">// TableHandle表示的是与当前TableScanNode对应的是数据源存储中的那个类</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">TableHandle</span><span class="w"> </span><span class="n">table</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  	</span><span class="c1">// outputSymbols: TableScanNode输出的symbols列表，在Presto中使用Symbol表示要输出哪些列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputSymbols</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  	</span><span class="c1">// assignments：对于outputSymbols中的每个Symbol，明确其来源于数据源Connector的那个Column（用ColumnHandle表示）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Symbol</span><span class="p">,</span><span class="w"> </span><span class="n">ColumnHandle</span><span class="o">&gt;</span><span class="w"> </span><span class="n">assignments</span><span class="p">;</span><span class="w"> </span><span class="c1">// symbol -&gt; column</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">TupleDomain</span><span class="o">&lt;</span><span class="n">ColumnHandle</span><span class="o">&gt;</span><span class="w"> </span><span class="n">enforcedConstraint</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">forDelete</span><span class="p">;</span></span></span></code></pre></div></div>
<p>查询执行时，只要将TableHandle、ColumnHandl交给数据源连接器，它就知道拉取那些表、哪些列的数据，这是一个基本抽象，在考虑到各种下推优化时，这两个概念将发挥更大的作用</p>]]></description>
</item>
</channel>
</rss>
