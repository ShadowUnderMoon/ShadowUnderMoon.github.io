<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Spark Shuffle机制 - 爱吃芒果</title><meta name=Description content="This is my cool site"><meta property="og:url" content="http://example.org/posts/spark_shuffle/">
<meta property="og:site_name" content="爱吃芒果"><meta property="og:title" content="Spark Shuffle机制"><meta property="og:description" content="运行在不同stage、不同节点上的task见通过shuffle机制传递数据，shuffle解决的问题是如何将数据进行重新组织，使其能够在上游和下游task之间进行传递和计算。如果只是单纯的数据传递，则只需要将数据进行分区、通过网络传输即可，没有太大的难度，但shuffle机制还需要进行各种类型的计算（如聚合、排序），而且数据量一般会很大，如果支持这些不同类型的计算，如果提高shuffle的性能都是shuffle机制设计的难点。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-01T09:18:40+08:00"><meta property="article:modified_time" content="2025-06-01T09:18:40+08:00"><meta property="article:tag" content="Spark"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spark Shuffle机制"><meta name=twitter:description content="运行在不同stage、不同节点上的task见通过shuffle机制传递数据，shuffle解决的问题是如何将数据进行重新组织，使其能够在上游和下游task之间进行传递和计算。如果只是单纯的数据传递，则只需要将数据进行分区、通过网络传输即可，没有太大的难度，但shuffle机制还需要进行各种类型的计算（如聚合、排序），而且数据量一般会很大，如果支持这些不同类型的计算，如果提高shuffle的性能都是shuffle机制设计的难点。"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=referrer content="no-referrer"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/spark_shuffle/><link rel=prev href=http://example.org/posts/java-concurrenthashmap/><link rel=next href=http://example.org/posts/spark_job_execution/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Spark Shuffle机制","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/spark_shuffle\/"},"genre":"posts","keywords":"Spark","wordcount":16903,"url":"http:\/\/example.org\/posts\/spark_shuffle\/","datePublished":"2025-06-01T09:18:40+08:00","dateModified":"2025-06-01T09:18:40+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"爱吃芒果"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=爱吃芒果>My cool site</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/page/archives/ title=Archives>Archives </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/page/search/ title=Search>Search </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=爱吃芒果>My cool site</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/page/archives/ title=Archives>Archives</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/page/search/ title=Search>Search</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Spark Shuffle机制</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>爱吃芒果</a></span>&nbsp;<span class=post-category>included in <a href=/categories/spark/><i class="far fa-folder fa-fw" aria-hidden=true></i>Spark</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2025-06-01>2025-06-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;16903 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;34 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#spark中shuffle框架的设计>Spark中Shuffle框架的设计</a><ul><li><a href=#shuffle-write框架设计和实现>Shuffle Write框架设计和实现</a></li><li><a href=#shuffle-read框架设计和实现>Shuffle Read框架设计和实现</a></li></ul></li><li><a href=#支持高效聚合和排序的数据结构>支持高效聚合和排序的数据结构</a><ul><li><a href=#appendonlymap>AppendOnlyMap</a></li><li><a href=#externalappendonlymap>ExternalAppendOnlyMap</a></li><li><a href=#partitionedappendonlymap>PartitionedAppendOnlyMap</a></li><li><a href=#partitionedpairbuffer>PartitionedPairBuffer</a></li><li><a href=#externalsorter>ExternalSorter</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>运行在不同stage、不同节点上的task见通过shuffle机制传递数据，shuffle解决的问题是如何将数据进行重新组织，使其能够在上游和下游task之间进行传递和计算。如果只是单纯的数据传递，则只需要将数据进行分区、通过网络传输即可，没有太大的难度，但shuffle机制还需要进行各种类型的计算（如聚合、排序），而且数据量一般会很大，如果支持这些不同类型的计算，如果提高shuffle的性能都是shuffle机制设计的难点。</p><p>shuffle机制分为shuffle write和shuffle read两个阶段，前者主要解决上游stage输出数据的分区问题，后者主要解决下游stage从上游stage获取数据、重新组织、并为后续操作提供数据的问题。</p><p>在shuffle过程中，我们将上游stage称为map stage，下游stage称为reduce stage，相应地，map stage包含多个map task，reduce stage包含多个reduce task。</p><p>分区个数和下游stage的task个数一致，分区个数可以通过用户自定义，如groupByKey(numPartitions)中的numPartitions一般被定义为集群中可用cpu个数的1~2倍，即将每个map task的输出数据划分为numPartitions份，相应地，在reduce stage中启动numPartition个task来获取并处理这些数据。如果用户没有自定义，则默认分区个数是parent RDD的分区个数的最大值。</p><p>对map task输出的每一个&lt;K, V> recod，根据Key计算其partitionId，具有不同partitionId的record被输出到不同的分区（文件）中。</p><p>数据聚合的本质是将相同key的record放在一起，并进行必要的计算，这个过程可以利用HashMap实现。方法是使用两步聚合（two-phase aggregation），先将不同tasks获取到的&lt;K, V> record存放到HashMap中，HashMap中的Key是K, Value是list(V)。然后，对于HashMap中每一个&lt;K, list(V)> record，使用func计算得到&lt;K, func(list(v))> record。两步聚合方案的优点是可以解决数据聚合问题，逻辑清晰、容易实现，缺点是所有shuffle的record都会先被存放到HashMap中，占用内存空间较大。另外，对于包含聚合函数的操作，如reduceByKey(func)，需要先将数据聚合到HashMap中以后再执行func()聚合函数，效率较低。</p><p>对于reduceByKey(func)等包含聚合函数的操作来说，我们可以采用一种在线聚合（Online aggregation）的方法来减少内存空间占用。该方法在每个record加入HashMap时，同时进行func()聚合操作，并更新相应的聚合结果。具体地，对于每一个新来的&lt;K, V> record，首先从HashMap中get出已经存在的结果V&rsquo; = HashMap.get(K)，然后执行聚合函数得到新的中间结果V&rsquo;&rsquo; = func(V, V&rsquo;)，最后将V&rsquo;&lsquo;写入HashMap中，即HashMap.put(K, V&rsquo;&rsquo;)。一般来说，聚合函数的执行结果会小于原始数据规模，即size(func(list(V))) &lt; Size(list(V))，如sum(), max()等，所以在线聚合可以减少内存消耗。在线聚合将Shuffle Read和聚合函数计算耦合在一起，可以加速计算。但是，对于不包含聚合函数的操作，如groupByKey()等，在线聚合和两步聚合没有差别，因为这些操作不包含聚合函数，无法减少中间数据规模。</p><p>Shuffle Writer端的combine操作的目的是减少Shuffle的数据量，只有包含聚合函数的数据操作需要进行map段的combine，对于不包含聚合函数的操作，如groupByKey，我们即使进行了combine操作，也不能减少中间数据的规模。从本质上将，combine和Shuffle Read端的聚合过程没有区别，都是将&lt;K, V> record聚合成&lt;K, func(list(V))>，不同的是，Shuffle Read端聚合的是来自所有map task输出的数据，而combine聚合的是来自单一task输出的数据。因此仍然可以采用Shuffle Read端基于HashMap的解决方案。具体地，首先利用HashMap进行combine，然后对HashMap中每一个record进行分区，输出到对应的分区文件中。</p><p>如果需要排序，在Shuffle Read端必须必须执行sort，因为从每个task获取的数据组合起来以后不是全局按Key进行排序的。其次，理论上，在Shuffle Write端不需要进行排序，但如果进行了排序，那么Shuffle Read获取到（来自不同task）的数据是已经部分有序的数据，可以减少Shuffle Read端排序的复杂度。</p><p>根据排序和聚合的顺序，有三种方案可供选择：</p><p>第一种方案是先排序后聚合，这种方案需要先使用线性数据结果如Array，存在Shuffle Read的&lt;K, V> record，然后对Key进行排序，排序后的数据可以直接从前到后进行扫描聚合，不需要再使用HashMap进行hash-based聚合。这种方案也是Hadoop MapReduce采用的方案，方案优点是既可以满足排序要求又可以满足聚合要求，缺点是需要较大内存来存储线性数据结构，同时排序和聚合过程不能同时进行，即不能使用在线聚合，效率较低。</p><p>第二种方案是排序和聚合同时进行，我们可以使用带有排序功能的Map，如TreeMap来对中间数据进行聚合，每次Shuffle Read获取到一个record，就将其放入TreeMap中与现有的record进行聚合，过程与HashMap类似，只有TreeMap自带排序功能。这种方案的优点是排序和聚合可以同时进行，缺点是相比HashMap，TreeMap的排序复杂度较高，TreeMap的插入时间复杂度为O(nlogn)，而且需要不断调整树的结果，不适合数据规模非常大的情况。</p><p>第三种方案是先聚合再排序，即维持现有基于HashMap的聚合方案不变，将HashMap中的record或record的引用放入线性数据结构中就行排序。这种方案的优点是聚合和排序过程独立，灵活性较高，而且之间的在线聚合方案不需要改动，缺点是需要复制（copy）数据或者引用，空间占用较大，Spark选择的是第三种方案，设计了特殊的HashMap来高效完成先聚合再排序的任务。</p><p>由于我们使用HashMap对数据进行combine和聚合，在数据量大的时候，会出现内存溢出，这个问题既可能出现在Shuffle Write阶段，也可能出现在Shuffle Read阶段。通过使用内存+磁盘混合存储来解决这个问题（吐磁盘），先在内存（如HashMap）中进行数据聚合，如果内存空间不足，则将内存中的数据spill到磁盘上，此时空闲出来的内存可以继续处理新的数据。此过程可以不断重复，直到数据处理完成。然而，问题是spill到磁盘上的数据实际上是部分聚合的结果，并没有和后续的数据进行过聚合。因此，为了得到完成的聚合结果，我们需要再进行下一步数据操作之前对磁盘上和内存中的数据进行再次聚合，这个过程我们称为全局聚合，为了加速全局聚合，我们需要将数据spill到磁盘上时进行排序，这样全局聚合才能够按照顺序读取spill到磁盘上的数据，并减少磁盘I/O。</p><h2 id=spark中shuffle框架的设计>Spark中Shuffle框架的设计</h2><h3 id=shuffle-write框架设计和实现>Shuffle Write框架设计和实现</h3><p>在Shuffle Write阶段，数据操作需要分区、聚合和排序3个功能，Spark为了支持所有可能的情况，设计了一个通用的Shuffle Write框架，框架的计算顺序为<code>map()输出 --> 数据聚合 --> 排序 --> 分区输出</code>。map task每计算出一个record及其partitionId，就将record放入类似HashMap的数据结构中进行聚合，聚合完成后，再将HashMap中的数据放入类似Array的数据结构中进行排序，即可按照partitionId，也可以按照partitionId+Key进行排序，最后根据partitionId将数据写入不同的数据分区中，存放到本地磁盘上。其中聚合和排序过程是可选的，如果数据操作不需要聚合或者排序，那么可以去掉相应的聚合或排序过程。</p><h4 id=不需要map端聚合和排序>不需要map端聚合和排序</h4><p>map依次输出&lt;K, V> record并计算其partititionId, Spark根据partitionId，将record依次输出到不同的buffer中，每当buffer填满就将record溢写到磁盘中的分区文件中。分配buffer的原因是map输出record的速度很快，需要进行缓冲来减少磁盘I/O。在实现代码中，Spark将这种Shuffle Write的方式称为BypassMergeSortShuffleWriter，即不需要进行排序的Shuffle Write方式。</p><p>该模式的优缺点：优点是速度快，直接将record输出到不同的分区文件中。缺点是资源消耗过高，每个分区都需要一个buffer（大小由spark.Shuffle.file.buffer控制，默认为32KB），且同时需要建立多个分区文件进行溢写。当分区个数太大，如10000，每个map task需要月320MB的内存，会造成内存消耗过大，而且每个task需要同时建立和打开10000个文件，造成资源不足，因此，该shuffle方案适合分区个数较少的情况（&lt; 200）。</p><p>该模式适用的操作类型：map端不需要聚合，key不需要排序且分区个数较少（&lt;=spark.Shuffle.sort.bypassMergeThreshold，默认值为200），例如 groupByKey(100)、partitionBy(100)、sortByKey(100)等，注意sortByKey是在Shuffle Rread端进行排序。</p><h4 id=不需要map端聚合但需要排序>不需要map端聚合，但需要排序</h4><p>在这种情况下需要按照partitionId+Key进行排序。Spark采用的实现方法是建立一个Array来存放map输出的record，并对Array中元素的Key进行精心设计，将每个&lt;K, V> record转化为&lt;(PID, K), V> record存储然后按照partitionId + Key对record进行排序，最后将所有record写入一个文件中，通过建立索引来标示每个分区。</p><p>如果Array存放不下，则会先扩容，如果还存放不下，就将Array中的record排序后spill到磁盘上，等待map输出完以后，再将Array中的record与磁盘上已排序的record进行全局排序，得到最终有序的record，并写入文件中。</p><p>该Shuffle模式被命名为SortShuffleWriter(KeyOrdering=true)，使用的Array被命名为PartitionedPairBuffer。</p><p>该Shuffle模式的优缺点：优点是只需要一个Array结构就可以支持按照partitionId+Key进行排序，Array大小可控，而且具有扩容和spill到磁盘的功能，支持从小规模到大规模数据的排序。同时，输出的数据已经按照partitionId进行排序，因此只需要一个分区文件存储，即可标示不同的分区数据，克服了ByPassMergeSortShuffleWriter中建立文件数过多的问题，适用于分区个数很大的情况，缺点是排序增加计算时延。</p><p>该Shuffle模式适用的操作：map端不需要聚合、Key需要排序、分区个数无限制。目前，Spark本身没有提供这种排序类型的数据操作，但不排除用户会自定义，或者系统未来会提供这种类型的操作。sortByKey操作虽然需要按Key进行排序，但这个排序过程在Shuffle Read端完成即可，不需要在Shuffle Write端进行排序。</p><p>SortShuffleWriter可以解决BypassMergeSortShuffleWriter模式的缺点，而BypassMergeSortShuffleWriter面向的操作不需要按照Key进行排序。因此，我们只需要将“按PartitionId+key”排序改成“只按PartitionId排序”，就可以支持不需要map端combine、不需要按照key进行排序、分区个数过大的操作，例如，groupByKey(300), partitionBy(300), sortByKey(300)。</p><h4 id=需要map段聚合需要或者不需要按照key进行排序>需要map段聚合，需要或者不需要按照key进行排序</h4><p>Spark采用的实现方法是建立一个类似HashMap的数据结构对map输出的record进行聚合。HashMap中的Key是partitionId+Key，HashMap中的Value是经过combine的聚合结果。聚合完成后，Spark对HashMap中的record进行排序，最后将排序后的record写入一个分区文件中。</p><p>该Shuffle模式的优缺点：优点是只需要一个HashMap结构就可以支持map端的combine功能，HashMap具有扩容和spill到磁盘的功能，支持小规模到大规模数据的聚合，也适用于分区个数很大的情况。在聚合后使用Array排序，可以灵活支持不同的排序需求。缺点是在内存中进行聚合，内存消耗较大，需要额外的数组进行排序，而且如果有数据spill到磁盘上，还需要再次进行聚合。在实现中，Spark在Shuffle Write端使用一个经过特殊设计和优化的HashMap，命名为PartitionedAppendOnlylMap，可以同时支持聚合和排序操作。相当于HashMap和Array的合体。</p><p>该Shuffle模式适用的操作：适合map端聚合、需要或者不需要按照Key进行排序，分区个数无限制的应用，如reduceByKey、aggregateByKey等。</p><h3 id=shuffle-read框架设计和实现>Shuffle Read框架设计和实现</h3><p>在Shuffle Read阶段，数据操作需要3个功能：跨节点数据获取、聚合和排序。Spark为了支持所有的情况，设计了一个通用的Shuffle Read框架，框架的计算顺序为数据获取&ndash;> 聚合 &mdash;> 排序输出。</p><h4 id=不需要聚合不需要按照key进行排序>不需要聚合，不需要按照Key进行排序</h4><p>这种情况最简单，只需要实现数据获取功能即可。等待所有的map task结束后, reduce task开始不断从各个map task获取&lt;K, V> record，并将record输出到一个buffer中（大小为spark.reducer.maxSizeInFlight=48MB），下一个操作直接从buffer获取即可。</p><p>该Shuffle模式的优缺点：优点是逻辑和实现简单，内存消耗很小。缺点是不支持聚合、排序等复杂功能。</p><p>该Shuffle模式适用的操作：适合既不需要聚合也不需要排序的应用，如partitionBy等。</p><h4 id=不需要聚合需要按key进行排序>不需要聚合，需要按Key进行排序</h4><p>获取数据后，将buffer中的record依次输出到一个Array结构（PartitionedPairBuffer）中。由于这里采用了本来用于Shuffle Write端的PartitionedPairBuffer结构，所以还保留了每个record的partitionId。然后，对Array中的record按照Key进行排序，并将排序结果输出或者传递给下一步操作。当内存无法存在所有的record时，PartitionedPairBuffer将record排序后spill到磁盘上，最后将内存中和磁盘上的record进行全局排序，得到最终排序后的record。</p><p>该Shuffle模式的优缺点：优点是只需要一个Array结构就可以支持按照Key进行排序，Array大小可控，而且具有扩容和spill到磁盘的功能，不受数据规模限制。缺点是排序增加计算时延。</p><p>该Shuffle模式适用的操作：适合reduce端不需要聚合，但需要按照Key进行排序的操作，如sortByKey，sortBy等。</p><h4 id=需要聚合不需要或者需要按key进行排序>需要聚合，不需要或者需要按Key进行排序</h4><p>获取record后，Spark建立一个类似HashMap的数据结构（ExternalAppendOnlyMap）对buffer中的record进行聚合，HashMap中的Key是record中的Key，HashMap中的Value是经过聚合函数计算后的结果。之后如果需要按照Key进行排序，则建立一个Array结构，读取HashMap中的record，并对record按Key进行排序，排序完成后，将结果输出或者传递给下一步操作。</p><p>该Shuffle模式的优缺点：优点是只需要一个HashMap和一个Array结构就可以支持reduce端的聚合和排序功能，HashMap具有扩容和spill到磁盘上的功能，支持小规模到大规模数据的聚合，边获取数据边聚合，效率较高。缺点是需要在内存中进行聚合，内存消费较大，如果有数据spill到磁盘上，还需要进行再次聚合。另外，经过HashMap聚合后的数据仍然需要拷贝到Array中进行排序，内存消耗较大。在实现中，Spark使用的HashMap是一个经过特殊优化的HashMap，命名为ExternalAppendOnlyMap，可以同时支持聚合和排序操作，相当于HashMap和Array的合体。</p><p>该Shuffle模式适用的操作：适合reduce端需要聚合、不需要或需要按Key进行排序的操作，如reduceByKey、aggregateByKey等。</p><h2 id=支持高效聚合和排序的数据结构>支持高效聚合和排序的数据结构</h2><p>仔细观察Shuffle Write/Read过程，我们会发现Shuffle机制中使用的数据结构的两个特征：</p><p>一是只需要支持record的插入和更新操作，不需要支持删除操作，这样我们可以对数据结构进行优化，减少内存消耗</p><p>二是只有内存放不下时才需要spill到磁盘上，因此数据结构设计以内存为主，磁盘为辅</p><h3 id=appendonlymap>AppendOnlyMap</h3><p>AppendOnlyMap实际上是一个只支持record添加和对Value进行更新的HashMap。于Java HashMap采用数组 + 链表的实现不同，AppendOnlyMap只使用数组来存储元素，根据元素的Hash值确定存储位置，如果存储元素时发生Hash值冲突，则使用二次地址探测法（Quadratic probing）来解决Hash值的冲突。</p><p>AppendOnlyMap将K, V相邻放在数组中，对于每个新来的&lt;K, V> record，先使用Hash(K)计算其存放位置，如果存放位置为空，就把record存放到该位置，如果该位置已经被占用，则根据二次探测法向后指数递增位置，直到发现空位。查找和更新操作也需要根据上面的流程进行寻址。</p><p>扩容：AppendOnlyMap使用数组来实现的问题是，如果插入的record太多，则很快就被填满，Spark的解决方案是，如果AppendOnlyMap的利用率达到70%，那么就扩张一倍，扩张意味着原来的Hash失效，因此对所有Key进行rehash，重新排列每个Key的位置。</p><p>排序：由于AppendOnlyMap采用了数组作为底层存储结构，可以支持快速排序等排序算法。实现层面，先将数组中所有的&lt;K, V> record转移到数组的前端，用begin和end来表示起始结束位置，然后调用排序算法对[begin, end]中的record进行排序。对于需要按Key进行排序的操作，如sortByKey，可以按照Key进行排序，对于其他操作，只按照Key的Hash值进行排序即可。</p><p>输出：迭代AppendOnlyMap数组中的record，从前往后扫描输出即可。</p><h5 id=源码分析>源码分析</h5><p>开放地址（Open addressing）是解决hash表中hash冲突的一种解决方案，通过探测或者搜索数组中的可选位置（被称为探测序列），直到目标记录被找到或者一个未使用的数组槽被发现。目前主要有以下三种探测方法：</p><ul><li>线性探测（Linear probing）探测序列之间的间隔固定，通常设置为1</li><li>二次探测（Quadratic probing）探测序列之间的间隔线性增长，因此下标可以通过二次函数来表示</li><li>双散列（Double hash）对于每条记录探测序列之间的间隔固定，通过另一个hash函数确定</li></ul><p>Spark中使用的是<a href=https://en.wikipedia.org/wiki/Quadratic_probing target=_blank rel="noopener noreffer">二次探测法</a>，如果数组长度为2的幂次方，假定为m，则可以选择探测序列 h, h + 1, h + 3 , h+ 6，间隔分别为1， 2， 3&mldr;，从而保证m长度的探测序列一定是所有数组下标的一种排列，所以只要数组中有空间，一定可以将元素顺利插入。</p><p>实现上和一般的HashMap差别不大，这里主要说一些不太一样的地方</p><p>AppendOnlyMap支持Key为null，对Key为null的情况特殊处理，使用字段<code>hashNullValue</code>和<code>nullValue</code>记录Key为null的record。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/** Get the value for a given key */</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=n>apply</span><span class=o>(</span><span class=n>key</span><span class=k>:</span> <span class=kt>K</span><span class=o>)</span><span class=k>:</span> <span class=kt>V</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=o>(!</span><span class=n>destroyed</span><span class=o>,</span> <span class=n>destructionMessage</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>k</span> <span class=k>=</span> <span class=n>key</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>k</span><span class=o>.</span><span class=n>eq</span><span class=o>(</span><span class=kc>null</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>nullValue</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>var</span> <span class=n>pos</span> <span class=k>=</span> <span class=n>rehash</span><span class=o>(</span><span class=n>k</span><span class=o>.</span><span class=n>hashCode</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span>
</span></span><span class=line><span class=cl>  <span class=k>var</span> <span class=n>i</span> <span class=k>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>curKey</span> <span class=k>=</span> <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>k</span><span class=o>.</span><span class=n>eq</span><span class=o>(</span><span class=n>curKey</span><span class=o>)</span> <span class=o>||</span> <span class=n>k</span><span class=o>.</span><span class=n>equals</span><span class=o>(</span><span class=n>curKey</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span> <span class=o>+</span> <span class=mi>1</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>V</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>curKey</span><span class=o>.</span><span class=n>eq</span><span class=o>(</span><span class=kc>null</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>null</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>V</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>delta</span> <span class=k>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>      <span class=n>pos</span> <span class=k>=</span> <span class=o>(</span><span class=n>pos</span> <span class=o>+</span> <span class=n>delta</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=kc>null</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>V</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p><code>apply</code>方法用于获取指定Key对应的Value，对AppendOnlyMap进行原地排序后，原先的HashMap的性质已经丧失，使用<code>destoryed</code>字段表示这种情况，除了对Key为null的特殊处理外，通过二次探测法寻找对应记录。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/** Set the value for a key */</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=n>update</span><span class=o>(</span><span class=n>key</span><span class=k>:</span> <span class=kt>K</span><span class=o>,</span> <span class=n>value</span><span class=k>:</span> <span class=kt>V</span><span class=o>)</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=o>(!</span><span class=n>destroyed</span><span class=o>,</span> <span class=n>destructionMessage</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>k</span> <span class=k>=</span> <span class=n>key</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>k</span><span class=o>.</span><span class=n>eq</span><span class=o>(</span><span class=kc>null</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(!</span><span class=n>haveNullValue</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>incrementSize</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>nullValue</span> <span class=k>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>    <span class=n>haveNullValue</span> <span class=k>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>var</span> <span class=n>pos</span> <span class=k>=</span> <span class=n>rehash</span><span class=o>(</span><span class=n>key</span><span class=o>.</span><span class=n>hashCode</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span>
</span></span><span class=line><span class=cl>  <span class=k>var</span> <span class=n>i</span> <span class=k>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>curKey</span> <span class=k>=</span> <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>curKey</span><span class=o>.</span><span class=n>eq</span><span class=o>(</span><span class=kc>null</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span><span class=o>)</span> <span class=k>=</span> <span class=n>k</span>
</span></span><span class=line><span class=cl>      <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span> <span class=k>=</span> <span class=n>value</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=n>incrementSize</span><span class=o>()</span>  <span class=c1>// Since we added a new key
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>k</span><span class=o>.</span><span class=n>eq</span><span class=o>(</span><span class=n>curKey</span><span class=o>)</span> <span class=o>||</span> <span class=n>k</span><span class=o>.</span><span class=n>equals</span><span class=o>(</span><span class=n>curKey</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span> <span class=k>=</span> <span class=n>value</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>delta</span> <span class=k>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>      <span class=n>pos</span> <span class=k>=</span> <span class=o>(</span><span class=n>pos</span> <span class=o>+</span> <span class=n>delta</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p><code>update</code>更新操作也是通过二次探测法寻找对应位置并插入或者更新。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Return an iterator of the map in sorted order. This provides a way to sort the map without
</span></span></span><span class=line><span class=cl><span class=cm> * using additional memory, at the expense of destroying the validity of the map.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=n>destructiveSortedIterator</span><span class=o>(</span><span class=n>keyComparator</span><span class=k>:</span> <span class=kt>Comparator</span><span class=o>[</span><span class=kt>K</span><span class=o>])</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>)]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>destroyed</span> <span class=k>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Pack KV pairs into the front of the underlying array
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>var</span> <span class=n>keyIndex</span><span class=o>,</span> <span class=n>newIndex</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=o>(</span><span class=n>keyIndex</span> <span class=o>&lt;</span> <span class=n>capacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>keyIndex</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>newIndex</span><span class=o>)</span> <span class=k>=</span> <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>keyIndex</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>newIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span> <span class=k>=</span> <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>keyIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>newIndex</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>keyIndex</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=o>(</span><span class=n>curSize</span> <span class=o>==</span> <span class=n>newIndex</span> <span class=o>+</span> <span class=o>(</span><span class=k>if</span> <span class=o>(</span><span class=n>haveNullValue</span><span class=o>)</span> <span class=mi>1</span> <span class=k>else</span> <span class=mi>0</span><span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>new</span> <span class=nc>Sorter</span><span class=o>(</span><span class=k>new</span> <span class=nc>KVArraySortDataFormat</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>AnyRef</span><span class=o>]).</span><span class=n>sort</span><span class=o>(</span><span class=n>data</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>newIndex</span><span class=o>,</span> <span class=n>keyComparator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>new</span> <span class=nc>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>)]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=n>i</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=n>nullValueReady</span> <span class=k>=</span> <span class=n>haveNullValue</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=n>hasNext</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>newIndex</span> <span class=o>||</span> <span class=n>nullValueReady</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=n>next</span><span class=o>()</span><span class=k>:</span> <span class=o>(</span><span class=kt>K</span><span class=o>,</span> <span class=kt>V</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>nullValueReady</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>nullValueReady</span> <span class=k>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=o>(</span><span class=kc>null</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>K</span><span class=o>],</span> <span class=n>nullValue</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=n>item</span> <span class=k>=</span> <span class=o>(</span><span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>i</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>K</span><span class=o>],</span> <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>V</span><span class=o>])</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>item</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p><code>destructiveSortedIterator</code>将HashMap中的所有记录整理到数组的开头，然后调用tim sort进行原地排序，tim sort结合了归并排序和插入排序，最后返回记录的迭代器。</p><h3 id=externalappendonlymap>ExternalAppendOnlyMap</h3><p>AppendOnlyMap的优点是能够将聚合和排序功能很好地结合在一起，缺点是只能使用内存，难以适用于内存空间不足的问题。为了解决这个问题，Spark基于AppendOnlyMap设计实现了基于内存+磁盘的ExternalAppendOnlyMap，用于Shuffle Read端大规模数据聚合。同时，由于Shuffle Write端聚合需要考虑partitionId，Spark也设计了带有partitionId的ExternalAppendOnlyMap，名为PartitionedAppendOnlyMap。</p><p>ExternalAppendOnlyMap的工作原理是，先持有一个AppendOnlyMap来不断接收和聚合新来的record，AppendOnlyMap快被装满时检查一下内存剩余空间是否可以扩展，可以的话直接在内存中扩展，否则对AppendOnlyMap中的record进行排序，然后将record都spill到磁盘上。因为record不断到来，可能会多次填满AppendOnlyMap，所以这个spill过程可以出现多次形成多个spill文件。等record都处理完，此时AppendOnlyMap中可能还留存一些聚合后的record，磁盘上也有多个spill文件。因为这些数据都经过了部分聚合，还需要进行全局聚合（merge）。因此ExternalAppendOnlyMap的最后一步是将内存中的AppendOnlyMap的数据和磁盘上spill文件中的数据进行全局聚合，得到最终结果。</p><h4 id=appendonlymap的大小估计>AppendOnlyMap的大小估计</h4><p>虽然我们知道AppendOnlyMap中持有的数组的长度和大小，但数组里面存放的是Key和Value的引用，并不是它们的实际对象大小，而且Value会不断被更新，实际大小不断变化。想要准备得到AppendOnlyMap的大小比较困难。一种简单的解决方法是在每次插入record或对现有record的Value进行更新后，都扫描一下AppendOnlyMap中存放的record，计算每个record的实际对象大小并相加，但这样会非常耗时。</p><p>Spark设计了一个增量式的高效估算算法，在每个record插入或更新时根据历史统计值和当前变化量直接估算当前AppendOnlyMap的大小，算法的复杂度为O(1)，开销很小，在record插入和聚合过程中会定期对当前AppendOnlyMap中的record进行抽样，然后精确计算这些record的总大小、总个数、更新个数及平均值等，并作为历史统计值。进行抽样是因为AppendOnlyMap中的record可能有上万个，难以对每个都精确计算。之后，每当有record插入或更新时，会根据历史统计值和历史平均的变化值，增量估算AppendOnlyMap的总大小，详见SizeTracker.estimateSize方法。抽样也会定期进行，更新统计值以获取更高的精度。</p><h4 id=spill过程与排序>Spill过程与排序</h4><p>当AppendOnlyMap达到内存限制时，会将record排序后写入磁盘中。排序是为了方便下一步全局聚合（聚合内存和磁盘上的record）时可以采用更高效的merge-sort（外部排序+聚合）。那么，问题是依据什么对record进行排序？自然想要可以根据record的Key进行排序，但是这就要求操作定义Key的排序方法，如sortByKey等操作定义了按照Key进行的排序。大部分操作，如groupByKey，并没有定义Key的排序方法，也不需要输出结果按照Key进行排序。在这种情况下，Spark采用按照Key的Hash值进行排序的方法，这样既可以进行merge-sort，又不要求操作定义Key排序的方法。然而，这种方法的问题是会出现Hash值冲突，也就是不同的Key具有相同的Hash值。为了解决这个问题，Spark在merge-sort的同时会比较Key的Hash值是否相等，以及Key的实际值是否相等。</p><h4 id=全局聚合>全局聚合</h4><p>由于最终的spill文件和内存中的AppendOnlyMap都是经过部分聚合后的结果，其中可能存在相同Key的record，因此还需要一个全局聚合阶段将AppendOnlyMap中的record与spill文件中的record进行聚合，得到最终聚合后的结果。</p><p>全局聚合的方法是建立一个最小堆或者最大堆，每次从各个spill文件中读取前几个具有相同Key（或者相同Key的hash值）的record，然后与AppendOnlyMap中的record进行聚合，并输出聚合后的结果。</p><h4 id=源码分析-1>源码分析</h4><h5 id=sizetracker>SizeTracker</h5><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * A general interface for collections to keep track of their estimated sizes in bytes.
</span></span></span><span class=line><span class=cl><span class=cm> * We sample with a slow exponential back-off using the SizeEstimator to amortize the time,
</span></span></span><span class=line><span class=cl><span class=cm> * as each call to SizeEstimator is somewhat expensive (order of a few milliseconds).
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>spark</span><span class=o>]</span> <span class=k>trait</span> <span class=nc>SizeTracker</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>import</span> <span class=nn>SizeTracker._</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Controls the base of the exponential which governs the rate of sampling.
</span></span></span><span class=line><span class=cl><span class=cm>   * E.g., a value of 2 would mean we sample at 1, 2, 4, 8, ... elements.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=nc>SAMPLE_GROWTH_RATE</span> <span class=k>=</span> <span class=mf>1.1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** Samples taken since last resetSamples(). Only the last two are kept for extrapolation. */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>samples</span> <span class=k>=</span> <span class=k>new</span> <span class=n>mutable</span><span class=o>.</span><span class=nc>Queue</span><span class=o>[</span><span class=kt>Sample</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** The average number of bytes per update between our last two samples. */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>bytesPerUpdate</span><span class=k>:</span> <span class=kt>Double</span> <span class=o>=</span> <span class=k>_</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** Total number of insertions and updates into the map since the last resetSamples(). */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>numUpdates</span><span class=k>:</span> <span class=kt>Long</span> <span class=o>=</span> <span class=k>_</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** The value of &#39;numUpdates&#39; at which we will take our next sample. */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>nextSampleNum</span><span class=k>:</span> <span class=kt>Long</span> <span class=o>=</span> <span class=k>_</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>resetSamples</span><span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Reset samples collected so far.
</span></span></span><span class=line><span class=cl><span class=cm>   * This should be called after the collection undergoes a dramatic change in size.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>protected</span> <span class=k>def</span> <span class=n>resetSamples</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>numUpdates</span> <span class=k>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>nextSampleNum</span> <span class=k>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>samples</span><span class=o>.</span><span class=n>clear</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=n>takeSample</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Callback to be invoked after every update.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>protected</span> <span class=k>def</span> <span class=n>afterUpdate</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>numUpdates</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>nextSampleNum</span> <span class=o>==</span> <span class=n>numUpdates</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>takeSample</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Take a new sample of the current collection&#39;s size.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>takeSample</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>samples</span><span class=o>.</span><span class=n>enqueue</span><span class=o>(</span><span class=nc>Sample</span><span class=o>(</span><span class=nc>SizeEstimator</span><span class=o>.</span><span class=n>estimate</span><span class=o>(</span><span class=k>this</span><span class=o>),</span> <span class=n>numUpdates</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Only use the last two samples to extrapolate
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>samples</span><span class=o>.</span><span class=n>size</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>samples</span><span class=o>.</span><span class=n>dequeue</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>bytesDelta</span> <span class=k>=</span> <span class=n>samples</span><span class=o>.</span><span class=n>toList</span><span class=o>.</span><span class=n>reverse</span> <span class=k>match</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=n>latest</span> <span class=k>:</span><span class=kt>:</span> <span class=kt>previous</span> <span class=kt>::</span> <span class=kt>tail</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>(</span><span class=n>latest</span><span class=o>.</span><span class=n>size</span> <span class=o>-</span> <span class=n>previous</span><span class=o>.</span><span class=n>size</span><span class=o>).</span><span class=n>toDouble</span> <span class=o>/</span> <span class=o>(</span><span class=n>latest</span><span class=o>.</span><span class=n>numUpdates</span> <span class=o>-</span> <span class=n>previous</span><span class=o>.</span><span class=n>numUpdates</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=c1>// If fewer than 2 samples, assume no change
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>case</span> <span class=k>_</span> <span class=k>=&gt;</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>bytesPerUpdate</span> <span class=k>=</span> <span class=n>math</span><span class=o>.</span><span class=n>max</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>bytesDelta</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>nextSampleNum</span> <span class=k>=</span> <span class=n>math</span><span class=o>.</span><span class=n>ceil</span><span class=o>(</span><span class=n>numUpdates</span> <span class=o>*</span> <span class=nc>SAMPLE_GROWTH_RATE</span><span class=o>).</span><span class=n>toLong</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Estimate the current size of the collection in bytes. O(1) time.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>estimateSize</span><span class=o>()</span><span class=k>:</span> <span class=kt>Long</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=o>(</span><span class=n>samples</span><span class=o>.</span><span class=n>nonEmpty</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>extrapolatedDelta</span> <span class=k>=</span> <span class=n>bytesPerUpdate</span> <span class=o>*</span> <span class=o>(</span><span class=n>numUpdates</span> <span class=o>-</span> <span class=n>samples</span><span class=o>.</span><span class=n>last</span><span class=o>.</span><span class=n>numUpdates</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>(</span><span class=n>samples</span><span class=o>.</span><span class=n>last</span><span class=o>.</span><span class=n>size</span> <span class=o>+</span> <span class=n>extrapolatedDelta</span><span class=o>).</span><span class=n>toLong</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>object</span> <span class=nc>SizeTracker</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=k>class</span> <span class=nc>Sample</span><span class=o>(</span><span class=n>size</span><span class=k>:</span> <span class=kt>Long</span><span class=o>,</span> <span class=n>numUpdates</span><span class=k>:</span> <span class=kt>Long</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>通过<code>SizeEstimator.estimate</code>估算当前容器占用的内存大小，通过指数退避算法周期性地采样，以均摊估算内存大小的成本。每次容器数据更新时，都增加<code>numUpdates</code>计数，如果达到了指数退避算法指定的采样计数<code>nextSampleNum</code>，则进行一次采样，并保留最近两次采样，计算最近两次采样间隔中每次更新数据增加的平均内存大小，则当前时刻的<code>estimateSize</code>是最近一次采样的容器大小 + 自上次采样以来的更新次数 * 每次更新数据增加的平均内存大小。</p><h5 id=sizetrackingappendonlymap>SizeTrackingAppendOnlyMap</h5><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>spark</span><span class=o>]</span> <span class=k>class</span> <span class=nc>SizeTrackingAppendOnlyMap</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=nc>extends</span> <span class=nc>AppendOnlyMap</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>]</span> <span class=k>with</span> <span class=nc>SizeTracker</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>update</span><span class=o>(</span><span class=n>key</span><span class=k>:</span> <span class=kt>K</span><span class=o>,</span> <span class=n>value</span><span class=k>:</span> <span class=kt>V</span><span class=o>)</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=o>.</span><span class=n>update</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=o>.</span><span class=n>afterUpdate</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>changeValue</span><span class=o>(</span><span class=n>key</span><span class=k>:</span> <span class=kt>K</span><span class=o>,</span> <span class=n>updateFunc</span><span class=k>:</span> <span class=o>(</span><span class=kt>Boolean</span><span class=o>,</span> <span class=kt>V</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>V</span><span class=o>)</span><span class=k>:</span> <span class=kt>V</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>newValue</span> <span class=k>=</span> <span class=k>super</span><span class=o>.</span><span class=n>changeValue</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>updateFunc</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=o>.</span><span class=n>afterUpdate</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=n>newValue</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>protected</span> <span class=k>def</span> <span class=n>growTable</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=o>.</span><span class=n>growTable</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=n>resetSamples</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>SizeTrackingAppendOnlyMap在每次更新数据时，都会增加更新计数，并决定是否采样。另外如果容器发生扩容，则重置采样数据。</p><h5 id=externalappendonlymap-1>ExternalAppendOnlyMap</h5><p>ExternalAppendOnlyMap拓展了<code>Spillable</code>，实现了吐磁盘的功能</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>class</span> <span class=nc>ExternalAppendOnlyMap</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span>, <span class=kt>C</span><span class=o>](</span>
</span></span><span class=line><span class=cl>    <span class=n>createCombiner</span><span class=k>:</span> <span class=kt>V</span> <span class=o>=&gt;</span> <span class=n>C</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>mergeValue</span><span class=k>:</span> <span class=o>(</span><span class=kt>C</span><span class=o>,</span> <span class=kt>V</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>C</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>mergeCombiners</span><span class=k>:</span> <span class=o>(</span><span class=kt>C</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>C</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>serializer</span><span class=k>:</span> <span class=kt>Serializer</span> <span class=o>=</span> <span class=nc>SparkEnv</span><span class=o>.</span><span class=n>get</span><span class=o>.</span><span class=n>serializer</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>blockManager</span><span class=k>:</span> <span class=kt>BlockManager</span> <span class=o>=</span> <span class=nc>SparkEnv</span><span class=o>.</span><span class=n>get</span><span class=o>.</span><span class=n>blockManager</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=k>:</span> <span class=kt>TaskContext</span> <span class=o>=</span> <span class=nc>TaskContext</span><span class=o>.</span><span class=n>get</span><span class=o>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>serializerManager</span><span class=k>:</span> <span class=kt>SerializerManager</span> <span class=o>=</span> <span class=nc>SparkEnv</span><span class=o>.</span><span class=n>get</span><span class=o>.</span><span class=n>serializerManager</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>extends</span> <span class=nc>Spillable</span><span class=o>[</span><span class=kt>SizeTracker</span><span class=o>](</span><span class=n>context</span><span class=o>.</span><span class=n>taskMemoryManager</span><span class=o>())</span>
</span></span><span class=line><span class=cl>  <span class=k>with</span> <span class=nc>Serializable</span>
</span></span><span class=line><span class=cl>  <span class=k>with</span> <span class=nc>Logging</span>
</span></span><span class=line><span class=cl>  <span class=k>with</span> <span class=nc>Iterable</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@volatile</span> <span class=k>private</span><span class=o>[</span><span class=kt>collection</span><span class=o>]</span> <span class=k>var</span> <span class=n>currentMap</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>SizeTrackingAppendOnlyMap</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>spilledMaps</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>ArrayBuffer</span><span class=o>[</span><span class=kt>DiskMapIterator</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>sparkConf</span> <span class=k>=</span> <span class=nc>SparkEnv</span><span class=o>.</span><span class=n>get</span><span class=o>.</span><span class=n>conf</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>diskBlockManager</span> <span class=k>=</span> <span class=n>blockManager</span><span class=o>.</span><span class=n>diskBlockManager</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Size of object batches when reading/writing from serializers.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * Objects are written in batches, with each batch using its own serialization stream. This
</span></span></span><span class=line><span class=cl><span class=cm>   * cuts down on the size of reference-tracking maps constructed when deserializing a stream.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * NOTE: Setting this too low can cause excessive copying when serializing, since some serializers
</span></span></span><span class=line><span class=cl><span class=cm>   * grow internal data structures by growing + copying every time the number of objects doubles.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>serializerBatchSize</span> <span class=k>=</span> <span class=n>sparkConf</span><span class=o>.</span><span class=n>get</span><span class=o>(</span><span class=n>config</span><span class=o>.</span><span class=nc>SHUFFLE_SPILL_BATCH_SIZE</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Number of bytes spilled in total
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>var</span> <span class=nc>_diskBytesSpilled</span> <span class=k>=</span> <span class=mi>0L</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>diskBytesSpilled</span><span class=k>:</span> <span class=kt>Long</span> <span class=o>=</span> <span class=nc>_diskBytesSpilled</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Use getSizeAsKb (not bytes) to maintain backwards compatibility if no units are provided
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>val</span> <span class=n>fileBufferSize</span> <span class=k>=</span> <span class=n>sparkConf</span><span class=o>.</span><span class=n>get</span><span class=o>(</span><span class=n>config</span><span class=o>.</span><span class=nc>SHUFFLE_FILE_BUFFER_SIZE</span><span class=o>).</span><span class=n>toInt</span> <span class=o>*</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Write metrics
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>val</span> <span class=n>writeMetrics</span><span class=k>:</span> <span class=kt>ShuffleWriteMetrics</span> <span class=o>=</span> <span class=k>new</span> <span class=nc>ShuffleWriteMetrics</span><span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Peak size of the in-memory map observed so far, in bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>var</span> <span class=nc>_peakMemoryUsedBytes</span><span class=k>:</span> <span class=kt>Long</span> <span class=o>=</span> <span class=mi>0L</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>peakMemoryUsedBytes</span><span class=k>:</span> <span class=kt>Long</span> <span class=o>=</span> <span class=nc>_peakMemoryUsedBytes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>keyComparator</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>HashComparator</span><span class=o>[</span><span class=kt>K</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>ser</span> <span class=k>=</span> <span class=n>serializer</span><span class=o>.</span><span class=n>newInstance</span><span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@volatile</span> <span class=k>private</span> <span class=k>var</span> <span class=n>readingIterator</span><span class=k>:</span> <span class=kt>SpillableIterator</span> <span class=o>=</span> <span class=kc>null</span></span></span></code></pre></div></div><p>字段：</p><p><code>currentMap</code>: SizeTrackingAppendOnlyMap，内存中的hash表，支持估计内存占用</p><p><code>spillendMaps</code>：ArrayBuffer[DiskMapIterator] 每次吐磁盘后，都会返回iterator用来遍历磁盘中的数据</p><p><code>_diskByteSpilled</code>：吐磁盘的总字节数</p><p><code>fileBufferSize</code>：每个shuffle文件输出流的buffer大小，通过<code>spark.shuffle.file.buffer</code>指定，默认是32k</p><p><code>keyComparator</code>：HashComparator，排序的目的是为了使用归并排序，不是所有操作都定义了按照Key的排序，所以这里使用基于Hash值的排序</p><p><code>readingIterator</code>：SpillableIterator TODO</p><p>方法：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Insert the given iterator of keys and values into the map.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * When the underlying map needs to grow, check if the global pool of shuffle memory has
</span></span></span><span class=line><span class=cl><span class=cm> * enough room for this to happen. If so, allocate the memory required to grow the map;
</span></span></span><span class=line><span class=cl><span class=cm> * otherwise, spill the in-memory map to disk.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * The shuffle memory usage of the first trackMemoryThreshold entries is not tracked.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=n>insertAll</span><span class=o>(</span><span class=n>entries</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[</span><span class=kt>Product2</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>]])</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>currentMap</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nc>IllegalStateException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;Cannot insert new elements into a map after calling iterator&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// An update function for the map that we reuse across entries to avoid allocating
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// a new closure each time
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>var</span> <span class=n>curEntry</span><span class=k>:</span> <span class=kt>Product2</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>]</span> <span class=k>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>update</span><span class=k>:</span> <span class=o>(</span><span class=kt>Boolean</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=n>C</span> <span class=k>=</span> <span class=o>(</span><span class=n>hadVal</span><span class=o>,</span> <span class=n>oldVal</span><span class=o>)</span> <span class=k>=&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>hadVal</span><span class=o>)</span> <span class=n>mergeValue</span><span class=o>(</span><span class=n>oldVal</span><span class=o>,</span> <span class=n>curEntry</span><span class=o>.</span><span class=n>_2</span><span class=o>)</span> <span class=k>else</span> <span class=n>createCombiner</span><span class=o>(</span><span class=n>curEntry</span><span class=o>.</span><span class=n>_2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 遍历每个K, V对
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=o>(</span><span class=n>entries</span><span class=o>.</span><span class=n>hasNext</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>curEntry</span> <span class=k>=</span> <span class=n>entries</span><span class=o>.</span><span class=n>next</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 插入前，先估算当前currentMap的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=n>estimatedSize</span> <span class=k>=</span> <span class=n>currentMap</span><span class=o>.</span><span class=n>estimateSize</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 更新巅峰占用内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>estimatedSize</span> <span class=o>&gt;</span> <span class=nc>_peakMemoryUsedBytes</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=nc>_peakMemoryUsedBytes</span> <span class=k>=</span> <span class=n>estimatedSize</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断是否spill，如果发生spill，创建新的currentMap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>maybeSpill</span><span class=o>(</span><span class=n>currentMap</span><span class=o>,</span> <span class=n>estimatedSize</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>currentMap</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>SizeTrackingAppendOnlyMap</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 插入新的记录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>currentMap</span><span class=o>.</span><span class=n>changeValue</span><span class=o>(</span><span class=n>curEntry</span><span class=o>.</span><span class=n>_1</span><span class=o>,</span> <span class=n>update</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 更新_elementsRead计数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addElementsRead</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>insertAll负责更新记录，如果内存占用超过限制，则吐磁盘，核心实现在<code>Spillable.maybeSpill</code>方法中。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=c1>// Initial threshold for the size of a collection before we start tracking its memory usage
</span></span></span><span class=line><span class=cl><span class=c1>// For testing only
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>[</span><span class=kt>this</span><span class=o>]</span> <span class=k>val</span> <span class=n>initialMemoryThreshold</span><span class=k>:</span> <span class=kt>Long</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=nc>SparkEnv</span><span class=o>.</span><span class=n>get</span><span class=o>.</span><span class=n>conf</span><span class=o>.</span><span class=n>get</span><span class=o>(</span><span class=nc>SHUFFLE_SPILL_INITIAL_MEM_THRESHOLD</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Threshold for this collection&#39;s size in bytes before we start tracking its memory usage
</span></span></span><span class=line><span class=cl><span class=c1>// To avoid a large number of small spills, initialize this to a value orders of magnitude &gt; 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nd>@volatile</span> <span class=k>private</span><span class=o>[</span><span class=kt>this</span><span class=o>]</span> <span class=k>var</span> <span class=n>myMemoryThreshold</span> <span class=k>=</span> <span class=n>initialMemoryThreshold</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Spills the current in-memory collection to disk if needed. Attempts to acquire more
</span></span></span><span class=line><span class=cl><span class=cm> * memory before spilling.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param collection collection to spill to disk
</span></span></span><span class=line><span class=cl><span class=cm> * @param currentMemory estimated size of the collection in bytes
</span></span></span><span class=line><span class=cl><span class=cm> * @return true if `collection` was spilled to disk; false otherwise
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>protected</span> <span class=k>def</span> <span class=n>maybeSpill</span><span class=o>(</span><span class=n>collection</span><span class=k>:</span> <span class=kt>C</span><span class=o>,</span> <span class=n>currentMemory</span><span class=k>:</span> <span class=kt>Long</span><span class=o>)</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>var</span> <span class=n>shouldSpill</span> <span class=k>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=c1>// myMemoryThresold的作用类似于内存配额，或者说已经申请到的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果当前内存占用大于申请到的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>(</span><span class=n>elementsRead</span> <span class=o>%</span> <span class=mi>32</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>currentMemory</span> <span class=o>&gt;=</span> <span class=n>myMemoryThreshold</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Claim up to double our current memory from the shuffle memory pool
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 尝试申请最多两倍的currentMemory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=n>amountToRequest</span> <span class=k>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>currentMemory</span> <span class=o>-</span> <span class=n>myMemoryThreshold</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>granted</span> <span class=k>=</span> <span class=n>acquireMemory</span><span class=o>(</span><span class=n>amountToRequest</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 更新申请到的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>myMemoryThreshold</span> <span class=o>+=</span> <span class=n>granted</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If we were granted too little memory to grow further (either tryToAcquire returned 0,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// or we already had more memory than myMemoryThreshold), spill the current collection
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果内存申请不到，并且集合的内存占用大于申请到的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>shouldSpill</span> <span class=k>=</span> <span class=n>currentMemory</span> <span class=o>&gt;=</span> <span class=n>myMemoryThreshold</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>shouldSpill</span> <span class=k>=</span> <span class=n>shouldSpill</span> <span class=o>||</span> <span class=nc>_elementsRead</span> <span class=o>&gt;</span> <span class=n>numElementsForceSpillThreshold</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Actually spill
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>(</span><span class=n>shouldSpill</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nc>_spillCount</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>logSpillage</span><span class=o>(</span><span class=n>currentMemory</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>spill</span><span class=o>(</span><span class=n>collection</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=nc>_elementsRead</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nc>_memoryBytesSpilled</span> <span class=o>+=</span> <span class=n>currentMemory</span>
</span></span><span class=line><span class=cl>    <span class=n>releaseMemory</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>shouldSpill</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p><code>spark.shuffle.spill.initialMemoryThreshold</code>默认为5kb，如果集合的内存占用低于指定值，则不会跟踪内存占用，避免大量的小集合被吐磁盘。</p><p><code>maybeSpill</code>如果当前集合的内存占用高于申请到的内存大小，则调用<code>spill(collection)</code>开始吐磁盘，并释放内存<code>releaseMemory</code>。</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Sort the existing contents of the in-memory map and spill them to a temporary file on disk.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>override</span> <span class=k>protected</span><span class=o>[</span><span class=kt>this</span><span class=o>]</span> <span class=k>def</span> <span class=n>spill</span><span class=o>(</span><span class=n>collection</span><span class=k>:</span> <span class=kt>SizeTracker</span><span class=o>)</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>inMemoryIterator</span> <span class=k>=</span> <span class=n>currentMap</span><span class=o>.</span><span class=n>destructiveSortedIterator</span><span class=o>(</span><span class=n>keyComparator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>diskMapIterator</span> <span class=k>=</span> <span class=n>spillMemoryIteratorToDisk</span><span class=o>(</span><span class=n>inMemoryIterator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=n>spilledMaps</span> <span class=o>+=</span> <span class=n>diskMapIterator</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Spill the in-memory Iterator to a temporary file on disk.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>this</span><span class=o>]</span> <span class=k>def</span> <span class=n>spillMemoryIteratorToDisk</span><span class=o>(</span><span class=n>inMemoryIterator</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>:</span> <span class=kt>DiskMapIterator</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 利用uuid创建一个临时的block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>val</span> <span class=o>(</span><span class=n>blockId</span><span class=o>,</span> <span class=n>file</span><span class=o>)</span> <span class=k>=</span> <span class=n>diskBlockManager</span><span class=o>.</span><span class=n>createTempLocalBlock</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 获取文件的writer
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>val</span> <span class=n>writer</span> <span class=k>=</span> <span class=n>blockManager</span><span class=o>.</span><span class=n>getDiskWriter</span><span class=o>(</span><span class=n>blockId</span><span class=o>,</span> <span class=n>file</span><span class=o>,</span> <span class=n>ser</span><span class=o>,</span> <span class=n>fileBufferSize</span><span class=o>,</span> <span class=n>writeMetrics</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>var</span> <span class=n>objectsWritten</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// List of batch sizes (bytes) in the order they are written to disk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>val</span> <span class=n>batchSizes</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>ArrayBuffer</span><span class=o>[</span><span class=kt>Long</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Flush the disk writer&#39;s contents to disk, and update relevant variables
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>def</span> <span class=n>flush</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>segment</span> <span class=k>=</span> <span class=n>writer</span><span class=o>.</span><span class=n>commitAndGet</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=n>batchSizes</span> <span class=o>+=</span> <span class=n>segment</span><span class=o>.</span><span class=n>length</span>
</span></span><span class=line><span class=cl>    <span class=nc>_diskBytesSpilled</span> <span class=o>+=</span> <span class=n>segment</span><span class=o>.</span><span class=n>length</span>
</span></span><span class=line><span class=cl>    <span class=n>objectsWritten</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>var</span> <span class=n>success</span> <span class=k>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历迭代器，分批将record flush到磁盘
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=o>(</span><span class=n>inMemoryIterator</span><span class=o>.</span><span class=n>hasNext</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>kv</span> <span class=k>=</span> <span class=n>inMemoryIterator</span><span class=o>.</span><span class=n>next</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=n>writer</span><span class=o>.</span><span class=n>write</span><span class=o>(</span><span class=n>kv</span><span class=o>.</span><span class=n>_1</span><span class=o>,</span> <span class=n>kv</span><span class=o>.</span><span class=n>_2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>objectsWritten</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>objectsWritten</span> <span class=o>==</span> <span class=n>serializerBatchSize</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>flush</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>objectsWritten</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>flush</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=n>writer</span><span class=o>.</span><span class=n>close</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>writer</span><span class=o>.</span><span class=n>revertPartialWritesAndClose</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>success</span> <span class=k>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(!</span><span class=n>success</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// This code path only happens if an exception was thrown above before we set success;
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// close our stuff and let the exception be thrown further
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>writer</span><span class=o>.</span><span class=n>closeAndDelete</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>new</span> <span class=nc>DiskMapIterator</span><span class=o>(</span><span class=n>file</span><span class=o>,</span> <span class=n>blockId</span><span class=o>,</span> <span class=n>batchSizes</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p><code>spill</code>首先调用hashMap的<code>destructiveSortedIterator</code>按照Key的hash值进行排序，然后将排好序的集合输出到磁盘。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Returns a destructive iterator for iterating over the entries of this map.
</span></span></span><span class=line><span class=cl><span class=cm> * If this iterator is forced spill to disk to release memory when there is not enough memory,
</span></span></span><span class=line><span class=cl><span class=cm> * it returns pairs from an on-disk map.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=n>destructiveIterator</span><span class=o>(</span><span class=n>inMemoryIterator</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)])</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>readingIterator</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>SpillableIterator</span><span class=o>(</span><span class=n>inMemoryIterator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=n>readingIterator</span><span class=o>.</span><span class=n>toCompletionIterator</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Return a destructive iterator that merges the in-memory map with the spilled maps.
</span></span></span><span class=line><span class=cl><span class=cm> * If no spill has occurred, simply return the in-memory map&#39;s iterator.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>override</span> <span class=k>def</span> <span class=n>iterator</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>currentMap</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nc>IllegalStateException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;ExternalAppendOnlyMap.iterator is destructive and should only be called once.&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>spilledMaps</span><span class=o>.</span><span class=n>isEmpty</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>destructiveIterator</span><span class=o>(</span><span class=n>currentMap</span><span class=o>.</span><span class=n>iterator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=nc>ExternalIterator</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>iterator返回map的迭代器，如果没有spill发生，直接返回内存中map的迭代器，否则返回一个合并了内存中map和磁盘中map的迭代器。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Wrapper around an iterator which calls a completion method after it successfully iterates
</span></span></span><span class=line><span class=cl><span class=cm> * through all the elements.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>spark</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>abstract</span> <span class=k>class</span> <span class=nc>CompletionIterator</span><span class=o>[</span> <span class=kt>+A</span>, <span class=kt>+I</span> <span class=k>&lt;:</span> <span class=kt>Iterator</span><span class=o>[</span><span class=kt>A</span><span class=o>]](</span><span class=n>sub</span><span class=k>:</span> <span class=kt>I</span><span class=o>)</span> <span class=k>extends</span> <span class=nc>Iterator</span><span class=o>[</span><span class=kt>A</span><span class=o>]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>[</span><span class=kt>this</span><span class=o>]</span> <span class=k>var</span> <span class=n>completed</span> <span class=k>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>[</span><span class=kt>this</span><span class=o>]</span> <span class=k>var</span> <span class=n>iter</span> <span class=k>=</span> <span class=n>sub</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>next</span><span class=o>()</span><span class=k>:</span> <span class=kt>A</span> <span class=o>=</span> <span class=n>iter</span><span class=o>.</span><span class=n>next</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>hasNext</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>r</span> <span class=k>=</span> <span class=n>iter</span><span class=o>.</span><span class=n>hasNext</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(!</span><span class=n>r</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>completed</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>completed</span> <span class=k>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>      <span class=c1>// reassign to release resources of highly resource consuming iterators early
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>iter</span> <span class=k>=</span> <span class=nc>Iterator</span><span class=o>.</span><span class=n>empty</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>I</span><span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=n>completion</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>completion</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>spark</span><span class=o>]</span> <span class=k>object</span> <span class=nc>CompletionIterator</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>apply</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>I</span> <span class=k>&lt;:</span> <span class=kt>Iterator</span><span class=o>[</span><span class=kt>A</span><span class=o>]](</span><span class=n>sub</span><span class=k>:</span> <span class=kt>I</span><span class=o>,</span> <span class=n>completionFunction</span><span class=k>:</span> <span class=o>=&gt;</span> <span class=nc>Unit</span><span class=o>)</span> <span class=k>:</span> <span class=kt>CompletionIterator</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>I</span><span class=o>]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=nc>CompletionIterator</span><span class=o>[</span><span class=kt>A</span>, <span class=kt>I</span><span class=o>](</span><span class=n>sub</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>def</span> <span class=n>completion</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=n>completionFunction</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>CompletionIterator包装了原先的Iterator，会在遍历完全部记录后，调用回调函数<code>completion</code>。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>private</span> <span class=k>class</span> <span class=nc>SpillableIterator</span><span class=o>(</span><span class=k>var</span> <span class=n>upstream</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)])</span>
</span></span><span class=line><span class=cl>  <span class=k>extends</span> <span class=nc>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=nc>SPILL_LOCK</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>Object</span><span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>cur</span><span class=k>:</span> <span class=o>(</span><span class=kt>K</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=</span> <span class=n>readNext</span><span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>hasSpilled</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>spill</span><span class=o>()</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=nc>SPILL_LOCK</span><span class=o>.</span><span class=n>synchronized</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>hasSpilled</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>logInfo</span><span class=o>(</span><span class=n>log</span><span class=s>&#34;Task ${MDC(TASK_ATTEMPT_ID, context.taskAttemptId())} force spilling&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=s>&#34; in-memory map to disk and it will release &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=s>&#34;${MDC(NUM_BYTES, org.apache.spark.util.Utils.bytesToString(getUsed()))} memory&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>nextUpstream</span> <span class=k>=</span> <span class=n>spillMemoryIteratorToDisk</span><span class=o>(</span><span class=n>upstream</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>assert</span><span class=o>(!</span><span class=n>upstream</span><span class=o>.</span><span class=n>hasNext</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>hasSpilled</span> <span class=k>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>      <span class=n>upstream</span> <span class=k>=</span> <span class=n>nextUpstream</span>
</span></span><span class=line><span class=cl>      <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>destroy</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>freeCurrentMap</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=n>upstream</span> <span class=k>=</span> <span class=nc>Iterator</span><span class=o>.</span><span class=n>empty</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>toCompletionIterator</span><span class=k>:</span> <span class=kt>CompletionIterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)</span>, <span class=kt>SpillableIterator</span><span class=o>]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nc>CompletionIterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)</span>, <span class=kt>SpillableIterator</span><span class=o>](</span><span class=k>this</span><span class=o>,</span> <span class=k>this</span><span class=o>.</span><span class=n>destroy</span><span class=o>())</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>readNext</span><span class=o>()</span><span class=k>:</span> <span class=o>(</span><span class=kt>K</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=</span> <span class=nc>SPILL_LOCK</span><span class=o>.</span><span class=n>synchronized</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>upstream</span><span class=o>.</span><span class=n>hasNext</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>upstream</span><span class=o>.</span><span class=n>next</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=kc>null</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>hasNext</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=n>cur</span> <span class=o>!=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>next</span><span class=o>()</span><span class=k>:</span> <span class=o>(</span><span class=kt>K</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>r</span> <span class=k>=</span> <span class=n>cur</span>
</span></span><span class=line><span class=cl>    <span class=n>cur</span> <span class=k>=</span> <span class=n>readNext</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p><code>SpillableIterator</code>也是上游迭代器的包装，支持spill操作，可以返回<code>CompletionIterator</code>，在遍历完成后调用<code>destory</code>清理资源。</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * An iterator that sort-merges (K, C) pairs from the in-memory map and the spilled maps
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>class</span> <span class=nc>ExternalIterator</span> <span class=k>extends</span> <span class=nc>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// A queue that maintains a buffer for each stream we are currently merging
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This queue maintains the invariant that it only contains non-empty buffers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 堆，用作堆排序
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>val</span> <span class=n>mergeHeap</span> <span class=k>=</span> <span class=k>new</span> <span class=n>mutable</span><span class=o>.</span><span class=nc>PriorityQueue</span><span class=o>[</span><span class=kt>StreamBuffer</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Input streams are derived both from the in-memory map and spilled maps on disk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// The in-memory map is sorted in place, while the spilled maps are already in sorted order
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// input stearam集合，包括内存中map和磁盘上map
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>val</span> <span class=n>sortedMap</span> <span class=k>=</span> <span class=n>destructiveIterator</span><span class=o>(</span>
</span></span><span class=line><span class=cl>    <span class=n>currentMap</span><span class=o>.</span><span class=n>destructiveSortedIterator</span><span class=o>(</span><span class=n>keyComparator</span><span class=o>))</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>inputStreams</span> <span class=k>=</span> <span class=o>(</span><span class=nc>Seq</span><span class=o>(</span><span class=n>sortedMap</span><span class=o>)</span> <span class=o>++</span> <span class=n>spilledMaps</span><span class=o>).</span><span class=n>map</span><span class=o>(</span><span class=n>it</span> <span class=k>=&gt;</span> <span class=n>it</span><span class=o>.</span><span class=n>buffered</span><span class=o>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 将每个iterator中最小hash值对应的多条记录保存到kcPairs，并放入堆中进行排序
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 每个iterator中，由于hash碰撞，可能出现多个Key对应同一个hash值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 但由于iterator中保存的都是聚合的结果，所以不可以有同一个key的多条记录
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>inputStreams</span><span class=o>.</span><span class=n>foreach</span> <span class=o>{</span> <span class=n>it</span> <span class=k>=&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>kcPairs</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>ArrayBuffer</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>readNextHashCode</span><span class=o>(</span><span class=n>it</span><span class=o>,</span> <span class=n>kcPairs</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>kcPairs</span><span class=o>.</span><span class=n>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>mergeHeap</span><span class=o>.</span><span class=n>enqueue</span><span class=o>(</span><span class=k>new</span> <span class=nc>StreamBuffer</span><span class=o>(</span><span class=n>it</span><span class=o>,</span> <span class=n>kcPairs</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>readNextHashCode</span><span class=o>(</span><span class=n>it</span><span class=k>:</span> <span class=kt>BufferedIterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)],</span> <span class=n>buf</span><span class=k>:</span> <span class=kt>ArrayBuffer</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)])</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=n>hasNext</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>var</span> <span class=n>kc</span> <span class=k>=</span> <span class=n>it</span><span class=o>.</span><span class=n>next</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=n>buf</span> <span class=o>+=</span> <span class=n>kc</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>minHash</span> <span class=k>=</span> <span class=n>hashKey</span><span class=o>(</span><span class=n>kc</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>while</span> <span class=o>(</span><span class=n>it</span><span class=o>.</span><span class=n>hasNext</span> <span class=o>&amp;&amp;</span> <span class=n>it</span><span class=o>.</span><span class=n>head</span><span class=o>.</span><span class=n>_1</span><span class=o>.</span><span class=n>hashCode</span><span class=o>()</span> <span class=o>==</span> <span class=n>minHash</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>kc</span> <span class=k>=</span> <span class=n>it</span><span class=o>.</span><span class=n>next</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=n>buf</span> <span class=o>+=</span> <span class=n>kc</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * If the given buffer contains a value for the given key, merge that value into
</span></span></span><span class=line><span class=cl><span class=cm>   * baseCombiner and remove the corresponding (K, C) pair from the buffer.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>mergeIfKeyExists</span><span class=o>(</span><span class=n>key</span><span class=k>:</span> <span class=kt>K</span><span class=o>,</span> <span class=n>baseCombiner</span><span class=k>:</span> <span class=kt>C</span><span class=o>,</span> <span class=n>buffer</span><span class=k>:</span> <span class=kt>StreamBuffer</span><span class=o>)</span><span class=k>:</span> <span class=kt>C</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=n>i</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历buffer中的记录，找到相同的key，并且merge，然后删除这条记录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>buffer</span><span class=o>.</span><span class=n>pairs</span><span class=o>.</span><span class=n>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>pair</span> <span class=k>=</span> <span class=n>buffer</span><span class=o>.</span><span class=n>pairs</span><span class=o>(</span><span class=n>i</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>pair</span><span class=o>.</span><span class=n>_1</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Note that there&#39;s at most one pair in the buffer with a given key, since we always
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// merge stuff in a map before spilling, so it&#39;s safe to return after the first we find
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>removeFromBuffer</span><span class=o>(</span><span class=n>buffer</span><span class=o>.</span><span class=n>pairs</span><span class=o>,</span> <span class=n>i</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mergeCombiners</span><span class=o>(</span><span class=n>baseCombiner</span><span class=o>,</span> <span class=n>pair</span><span class=o>.</span><span class=n>_2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>baseCombiner</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 这里通过交换元素并移除最后一个元素的方式实现高效的移除任意元素
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>def</span> <span class=n>removeFromBuffer</span><span class=o>[</span><span class=kt>T</span><span class=o>](</span><span class=n>buffer</span><span class=k>:</span> <span class=kt>ArrayBuffer</span><span class=o>[</span><span class=kt>T</span><span class=o>],</span> <span class=n>index</span><span class=k>:</span> <span class=kt>Int</span><span class=o>)</span><span class=k>:</span> <span class=kt>T</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>elem</span> <span class=k>=</span> <span class=n>buffer</span><span class=o>(</span><span class=n>index</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span><span class=o>(</span><span class=n>index</span><span class=o>)</span> <span class=k>=</span> <span class=n>buffer</span><span class=o>(</span><span class=n>buffer</span><span class=o>.</span><span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span>  <span class=c1>// This also works if index == buffer.size - 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>buffer</span><span class=o>.</span><span class=n>dropRightInPlace</span><span class=o>(</span><span class=mi>1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>elem</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Return true if there exists an input stream that still has unvisited pairs.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>hasNext</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=n>mergeHeap</span><span class=o>.</span><span class=n>nonEmpty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Select a key with the minimum hash, then combine all values with the same key from all
</span></span></span><span class=line><span class=cl><span class=cm>   * input streams.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>next</span><span class=o>()</span><span class=k>:</span> <span class=o>(</span><span class=kt>K</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>mergeHeap</span><span class=o>.</span><span class=n>isEmpty</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nc>NoSuchElementException</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Select a key from the StreamBuffer that holds the lowest key hash
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 取出拥有最小hash值的buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=n>minBuffer</span> <span class=k>=</span> <span class=n>mergeHeap</span><span class=o>.</span><span class=n>dequeue</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>minPairs</span> <span class=k>=</span> <span class=n>minBuffer</span><span class=o>.</span><span class=n>pairs</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>minHash</span> <span class=k>=</span> <span class=n>minBuffer</span><span class=o>.</span><span class=n>minKeyHash</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>minPair</span> <span class=k>=</span> <span class=n>removeFromBuffer</span><span class=o>(</span><span class=n>minPairs</span><span class=o>,</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>minKey</span> <span class=k>=</span> <span class=n>minPair</span><span class=o>.</span><span class=n>_1</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=n>minCombiner</span> <span class=k>=</span> <span class=n>minPair</span><span class=o>.</span><span class=n>_2</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=o>(</span><span class=n>hashKey</span><span class=o>(</span><span class=n>minPair</span><span class=o>)</span> <span class=o>==</span> <span class=n>minHash</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// For all other streams that may have this key (i.e. have the same minimum key hash),
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// merge in the corresponding value (if any) from that stream
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 查询堆顶元素，如果hash值相同，则出队，并尝试合并相同Key的记录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=n>mergedBuffers</span> <span class=k>=</span> <span class=nc>ArrayBuffer</span><span class=o>[</span><span class=kt>StreamBuffer</span><span class=o>](</span><span class=n>minBuffer</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=o>(</span><span class=n>mergeHeap</span><span class=o>.</span><span class=n>nonEmpty</span> <span class=o>&amp;&amp;</span> <span class=n>mergeHeap</span><span class=o>.</span><span class=n>head</span><span class=o>.</span><span class=n>minKeyHash</span> <span class=o>==</span> <span class=n>minHash</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>newBuffer</span> <span class=k>=</span> <span class=n>mergeHeap</span><span class=o>.</span><span class=n>dequeue</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=n>minCombiner</span> <span class=k>=</span> <span class=n>mergeIfKeyExists</span><span class=o>(</span><span class=n>minKey</span><span class=o>,</span> <span class=n>minCombiner</span><span class=o>,</span> <span class=n>newBuffer</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>mergedBuffers</span> <span class=o>+=</span> <span class=n>newBuffer</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Repopulate each visited stream buffer and add it back to the queue if it is non-empty
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 检查出队的iterator是否为空，如果为空，则丢弃，否则如果buffer不为空，直接入队
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果buffer为空，读取下一个最小的hash值的记录，并入队
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mergedBuffers</span><span class=o>.</span><span class=n>foreach</span> <span class=o>{</span> <span class=n>buffer</span> <span class=k>=&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>buffer</span><span class=o>.</span><span class=n>isEmpty</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>readNextHashCode</span><span class=o>(</span><span class=n>buffer</span><span class=o>.</span><span class=n>iterator</span><span class=o>,</span> <span class=n>buffer</span><span class=o>.</span><span class=n>pairs</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(!</span><span class=n>buffer</span><span class=o>.</span><span class=n>isEmpty</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mergeHeap</span><span class=o>.</span><span class=n>enqueue</span><span class=o>(</span><span class=n>buffer</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>(</span><span class=n>minKey</span><span class=o>,</span> <span class=n>minCombiner</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>class</span> <span class=nc>StreamBuffer</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>iterator</span><span class=k>:</span> <span class=kt>BufferedIterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)],</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>pairs</span><span class=k>:</span> <span class=kt>ArrayBuffer</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>extends</span> <span class=nc>Comparable</span><span class=o>[</span><span class=kt>StreamBuffer</span><span class=o>]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=n>isEmpty</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=n>pairs</span><span class=o>.</span><span class=n>length</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Invalid if there are no more pairs in this stream
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>def</span> <span class=n>minKeyHash</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>assert</span><span class=o>(</span><span class=n>pairs</span><span class=o>.</span><span class=n>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>hashKey</span><span class=o>(</span><span class=n>pairs</span><span class=o>.</span><span class=n>head</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>def</span> <span class=n>compareTo</span><span class=o>(</span><span class=n>other</span><span class=k>:</span> <span class=kt>StreamBuffer</span><span class=o>)</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// descending order because mutable.PriorityQueue dequeues the max, not the min
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=o>(</span><span class=n>other</span><span class=o>.</span><span class=n>minKeyHash</span> <span class=o>&lt;</span> <span class=n>minKeyHash</span><span class=o>)</span> <span class=o>-</span><span class=mi>1</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>other</span><span class=o>.</span><span class=n>minKeyHash</span> <span class=o>==</span> <span class=n>minKeyHash</span><span class=o>)</span> <span class=mi>0</span> <span class=k>else</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>ExternalIterator通过堆排序对内存中map和磁盘上map的iterator进行合并。</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * An iterator that returns (K, C) pairs in sorted order from an on-disk map
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>class</span> <span class=nc>DiskMapIterator</span><span class=o>(</span><span class=n>file</span><span class=k>:</span> <span class=kt>File</span><span class=o>,</span> <span class=n>blockId</span><span class=k>:</span> <span class=kt>BlockId</span><span class=o>,</span> <span class=n>batchSizes</span><span class=k>:</span> <span class=kt>ArrayBuffer</span><span class=o>[</span><span class=kt>Long</span><span class=o>])</span>
</span></span><span class=line><span class=cl>  <span class=k>extends</span> <span class=nc>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>val</span> <span class=n>batchOffsets</span> <span class=k>=</span> <span class=n>batchSizes</span><span class=o>.</span><span class=n>scanLeft</span><span class=o>(</span><span class=mi>0L</span><span class=o>)(</span><span class=k>_</span> <span class=o>+</span> <span class=k>_</span><span class=o>)</span>  <span class=c1>// Size will be batchSize.length + 1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assert</span><span class=o>(</span><span class=n>file</span><span class=o>.</span><span class=n>length</span><span class=o>()</span> <span class=o>==</span> <span class=n>batchOffsets</span><span class=o>.</span><span class=n>last</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;File length is not equal to the last batch offset:\n&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=s>s&#34;    file length = </span><span class=si>${</span><span class=n>file</span><span class=o>.</span><span class=n>length</span><span class=si>}</span><span class=s>\n&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=s>s&#34;    last batch offset = </span><span class=si>${</span><span class=n>batchOffsets</span><span class=o>.</span><span class=n>last</span><span class=si>}</span><span class=s>\n&#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=s>s&#34;    all batch offsets = </span><span class=si>${</span><span class=n>batchOffsets</span><span class=o>.</span><span class=n>mkString</span><span class=o>(</span><span class=s>&#34;,&#34;</span><span class=o>)</span><span class=si>}</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>  <span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>batchIndex</span> <span class=k>=</span> <span class=mi>0</span>  <span class=c1>// Which batch we&#39;re in
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>var</span> <span class=n>fileStream</span><span class=k>:</span> <span class=kt>FileInputStream</span> <span class=o>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// An intermediate stream that reads from exactly one batch
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This guards against pre-fetching and other arbitrary behavior of higher level streams
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>var</span> <span class=n>deserializeStream</span><span class=k>:</span> <span class=kt>DeserializationStream</span> <span class=o>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>batchIterator</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span> <span class=k>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>objectsRead</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Construct a stream that reads only from the next batch.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>nextBatchIterator</span><span class=o>()</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Note that batchOffsets.length = numBatches + 1 since we did a scan above; check whether
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// we&#39;re still in a valid batch.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>batchIndex</span> <span class=o>&lt;</span> <span class=n>batchOffsets</span><span class=o>.</span><span class=n>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>deserializeStream</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>deserializeStream</span><span class=o>.</span><span class=n>close</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=n>fileStream</span><span class=o>.</span><span class=n>close</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=n>deserializeStream</span> <span class=k>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>        <span class=n>fileStream</span> <span class=k>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>start</span> <span class=k>=</span> <span class=n>batchOffsets</span><span class=o>(</span><span class=n>batchIndex</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>fileStream</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>FileInputStream</span><span class=o>(</span><span class=n>file</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>fileStream</span><span class=o>.</span><span class=n>getChannel</span><span class=o>.</span><span class=n>position</span><span class=o>(</span><span class=n>start</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>batchIndex</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>end</span> <span class=k>=</span> <span class=n>batchOffsets</span><span class=o>(</span><span class=n>batchIndex</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>assert</span><span class=o>(</span><span class=n>end</span> <span class=o>&gt;=</span> <span class=n>start</span><span class=o>,</span> <span class=s>&#34;start = &#34;</span> <span class=o>+</span> <span class=n>start</span> <span class=o>+</span> <span class=s>&#34;, end = &#34;</span> <span class=o>+</span> <span class=n>end</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;, batchOffsets = &#34;</span> <span class=o>+</span> <span class=n>batchOffsets</span><span class=o>.</span><span class=n>mkString</span><span class=o>(</span><span class=s>&#34;[&#34;</span><span class=o>,</span> <span class=s>&#34;, &#34;</span><span class=o>,</span> <span class=s>&#34;]&#34;</span><span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>bufferedStream</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>BufferedInputStream</span><span class=o>(</span><span class=nc>ByteStreams</span><span class=o>.</span><span class=n>limit</span><span class=o>(</span><span class=n>fileStream</span><span class=o>,</span> <span class=n>end</span> <span class=o>-</span> <span class=n>start</span><span class=o>))</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>wrappedStream</span> <span class=k>=</span> <span class=n>serializerManager</span><span class=o>.</span><span class=n>wrapStream</span><span class=o>(</span><span class=n>blockId</span><span class=o>,</span> <span class=n>bufferedStream</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>deserializeStream</span> <span class=k>=</span> <span class=n>ser</span><span class=o>.</span><span class=n>deserializeStream</span><span class=o>(</span><span class=n>wrappedStream</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>deserializeStream</span><span class=o>.</span><span class=n>asKeyValueIterator</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>Iterator</span><span class=o>[(</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>)]]</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// No more batches left
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>cleanup</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=kc>null</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Return the next (K, C) pair from the deserialization stream.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * If the current batch is drained, construct a stream for the next batch and read from it.
</span></span></span><span class=line><span class=cl><span class=cm>   * If no more pairs are left, return null.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>readNextItem</span><span class=o>()</span><span class=k>:</span> <span class=o>(</span><span class=kt>K</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>item</span> <span class=k>=</span> <span class=n>batchIterator</span><span class=o>.</span><span class=n>next</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=n>objectsRead</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>objectsRead</span> <span class=o>==</span> <span class=n>serializerBatchSize</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>objectsRead</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>      <span class=n>batchIterator</span> <span class=k>=</span> <span class=n>nextBatchIterator</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>item</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>hasNext</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>batchIterator</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// In case of batchIterator has not been initialized
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>batchIterator</span> <span class=k>=</span> <span class=n>nextBatchIterator</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>batchIterator</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>batchIterator</span><span class=o>.</span><span class=n>hasNext</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>next</span><span class=o>()</span><span class=k>:</span> <span class=o>(</span><span class=kt>K</span><span class=o>,</span> <span class=kt>C</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(!</span><span class=n>hasNext</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nc>NoSuchElementException</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>readNextItem</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>cleanup</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>batchIndex</span> <span class=k>=</span> <span class=n>batchOffsets</span><span class=o>.</span><span class=n>length</span>  <span class=c1>// Prevent reading any other batch
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>deserializeStream</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>deserializeStream</span><span class=o>.</span><span class=n>close</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=n>deserializeStream</span> <span class=k>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>fileStream</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>fileStream</span><span class=o>.</span><span class=n>close</span><span class=o>()</span>
</span></span><span class=line><span class=cl>      <span class=n>fileStream</span> <span class=k>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>file</span><span class=o>.</span><span class=n>exists</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(!</span><span class=n>file</span><span class=o>.</span><span class=n>delete</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>logWarning</span><span class=o>(</span><span class=n>log</span><span class=s>&#34;Error deleting ${MDC(FILE_NAME, file)}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>context</span><span class=o>.</span><span class=n>addTaskCompletionListener</span><span class=o>[</span><span class=kt>Unit</span><span class=o>](</span><span class=n>context</span> <span class=k>=&gt;</span> <span class=n>cleanup</span><span class=o>())</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p><code>DiskMapIterator</code>从磁盘中的shuffle文件中读取Key、Value键值对，由于shuffle文件是分批写入的，并且每次达到<code>serializerBatchSize</code>将之前的内容批量写入。</p><p>所以读取时，如果达到<code>serializerBatchSize</code>也需要新创建一个批的读取stream。</p><h5 id=hashcomparator>HashComparator</h5><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * A comparator which sorts arbitrary keys based on their hash codes.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>class</span> <span class=nc>HashComparator</span><span class=o>[</span><span class=kt>K</span><span class=o>]</span> <span class=nc>extends</span> <span class=nc>Comparator</span><span class=o>[</span><span class=kt>K</span><span class=o>]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>compare</span><span class=o>(</span><span class=n>key1</span><span class=k>:</span> <span class=kt>K</span><span class=o>,</span> <span class=n>key2</span><span class=k>:</span> <span class=kt>K</span><span class=o>)</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>hash1</span> <span class=k>=</span> <span class=n>hash</span><span class=o>(</span><span class=n>key1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>hash2</span> <span class=k>=</span> <span class=n>hash</span><span class=o>(</span><span class=n>key2</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>hash1</span> <span class=o>&lt;</span> <span class=n>hash2</span><span class=o>)</span> <span class=o>-</span><span class=mi>1</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>hash1</span> <span class=o>==</span> <span class=n>hash2</span><span class=o>)</span> <span class=mi>0</span> <span class=k>else</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>HashComparator的实现非常简单，计算hash值，并根据hash值的大小进行排序。</p><h3 id=partitionedappendonlymap>PartitionedAppendOnlyMap</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Implementation of WritablePartitionedPairCollection that wraps a map in which the keys are tuples
</span></span></span><span class=line><span class=cl><span class=cm> * of (partition ID, K)
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>spark</span><span class=o>]</span> <span class=k>class</span> <span class=nc>PartitionedAppendOnlyMap</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=nc>extends</span> <span class=nc>SizeTrackingAppendOnlyMap</span><span class=o>[(</span><span class=kt>Int</span>, <span class=kt>K</span><span class=o>)</span>, <span class=kt>V</span><span class=o>]</span> <span class=k>with</span> <span class=nc>WritablePartitionedPairCollection</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>partitionedDestructiveSortedIterator</span><span class=o>(</span><span class=n>keyComparator</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>Comparator</span><span class=o>[</span><span class=kt>K</span><span class=o>]])</span>
</span></span><span class=line><span class=cl>    <span class=k>:</span> <span class=kt>Iterator</span><span class=o>[((</span><span class=kt>Int</span>, <span class=kt>K</span><span class=o>)</span>, <span class=kt>V</span><span class=o>)]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>comparator</span> <span class=k>=</span> <span class=n>keyComparator</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>partitionKeyComparator</span><span class=o>).</span><span class=n>getOrElse</span><span class=o>(</span><span class=n>partitionComparator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>destructiveSortedIterator</span><span class=o>(</span><span class=n>comparator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>insert</span><span class=o>(</span><span class=n>partition</span><span class=k>:</span> <span class=kt>Int</span><span class=o>,</span> <span class=n>key</span><span class=k>:</span> <span class=kt>K</span><span class=o>,</span> <span class=n>value</span><span class=k>:</span> <span class=kt>V</span><span class=o>)</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=o>((</span><span class=n>partition</span><span class=o>,</span> <span class=n>key</span><span class=o>),</span> <span class=n>value</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>PartitionedAppendOnlyMap用于在Shuffle Write端对record进行聚合（combine）。PartitionedAppendOnlyMap的功能和实现与ExternalAppendOnlyMap的功能和实现基本一样，唯一区别是PartitionedAppendOnlyMap中的Key是PartitionId + Key，这样既可以根据partitionId进行排序（面向不需要按key进行排序的操作），也可以根据partitionId + Key进行排序（面向需要按Key进行排序的操作），从而在Shuffle Write阶段可以进行聚合、排序和分区。</p><h3 id=partitionedpairbuffer>PartitionedPairBuffer</h3><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>spark</span><span class=o>]</span> <span class=k>class</span> <span class=nc>PartitionedPairBuffer</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>](</span><span class=n>initialCapacity</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=mi>64</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>extends</span> <span class=nc>WritablePartitionedPairCollection</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span><span class=o>]</span> <span class=k>with</span> <span class=nc>SizeTracker</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>import</span> <span class=nn>PartitionedPairBuffer._</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>require</span><span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&lt;=</span> <span class=nc>MAXIMUM_CAPACITY</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=s>s&#34;Can&#39;t make capacity bigger than </span><span class=si>${</span><span class=nc>MAXIMUM_CAPACITY</span><span class=si>}</span><span class=s> elements&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=n>require</span><span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=o>,</span> <span class=s>&#34;Invalid initial capacity&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Basic growable array data structure. We use a single array of AnyRef to hold both the keys
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// and the values, so that we can sort them efficiently with KVArraySortDataFormat.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span> <span class=k>var</span> <span class=n>capacity</span> <span class=k>=</span> <span class=n>initialCapacity</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>curSize</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>var</span> <span class=n>data</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>Array</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>](</span><span class=mi>2</span> <span class=o>*</span> <span class=n>initialCapacity</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** Add an element into the buffer */</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=n>insert</span><span class=o>(</span><span class=n>partition</span><span class=k>:</span> <span class=kt>Int</span><span class=o>,</span> <span class=n>key</span><span class=k>:</span> <span class=kt>K</span><span class=o>,</span> <span class=n>value</span><span class=k>:</span> <span class=kt>V</span><span class=o>)</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>curSize</span> <span class=o>==</span> <span class=n>capacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>growArray</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>curSize</span><span class=o>)</span> <span class=k>=</span> <span class=o>(</span><span class=n>partition</span><span class=o>,</span> <span class=n>key</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>])</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>curSize</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span> <span class=k>=</span> <span class=n>value</span><span class=o>.</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=n>curSize</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>afterUpdate</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** Double the size of the array because we&#39;ve reached capacity */</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>growArray</span><span class=o>()</span><span class=k>:</span> <span class=kt>Unit</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>capacity</span> <span class=o>&gt;=</span> <span class=nc>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nc>IllegalStateException</span><span class=o>(</span><span class=s>s&#34;Can&#39;t insert more than </span><span class=si>${</span><span class=nc>MAXIMUM_CAPACITY</span><span class=si>}</span><span class=s> elements&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>newCapacity</span> <span class=k>=</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>capacity</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>&gt;</span> <span class=nc>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// Overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nc>MAXIMUM_CAPACITY</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>capacity</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>newArray</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>Array</span><span class=o>[</span><span class=kt>AnyRef</span><span class=o>](</span><span class=mi>2</span> <span class=o>*</span> <span class=n>newCapacity</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=nc>System</span><span class=o>.</span><span class=n>arraycopy</span><span class=o>(</span><span class=n>data</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>newArray</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>capacity</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=k>=</span> <span class=n>newArray</span>
</span></span><span class=line><span class=cl>    <span class=n>capacity</span> <span class=k>=</span> <span class=n>newCapacity</span>
</span></span><span class=line><span class=cl>    <span class=n>resetSamples</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** Iterate through the data in a given order. For this class this is not really destructive. */</span>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>def</span> <span class=n>partitionedDestructiveSortedIterator</span><span class=o>(</span><span class=n>keyComparator</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>Comparator</span><span class=o>[</span><span class=kt>K</span><span class=o>]])</span>
</span></span><span class=line><span class=cl>    <span class=k>:</span> <span class=kt>Iterator</span><span class=o>[((</span><span class=kt>Int</span>, <span class=kt>K</span><span class=o>)</span>, <span class=kt>V</span><span class=o>)]</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>comparator</span> <span class=k>=</span> <span class=n>keyComparator</span><span class=o>.</span><span class=n>map</span><span class=o>(</span><span class=n>partitionKeyComparator</span><span class=o>).</span><span class=n>getOrElse</span><span class=o>(</span><span class=n>partitionComparator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=nc>Sorter</span><span class=o>(</span><span class=k>new</span> <span class=nc>KVArraySortDataFormat</span><span class=o>[(</span><span class=kt>Int</span>, <span class=kt>K</span><span class=o>)</span>, <span class=kt>AnyRef</span><span class=o>]).</span><span class=n>sort</span><span class=o>(</span><span class=n>data</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>curSize</span><span class=o>,</span> <span class=n>comparator</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>iterator</span><span class=o>()</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>def</span> <span class=n>iterator</span><span class=o>()</span><span class=k>:</span> <span class=kt>Iterator</span><span class=o>[((</span><span class=kt>Int</span>, <span class=kt>K</span><span class=o>)</span>, <span class=kt>V</span><span class=o>)]</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>Iterator</span><span class=o>[((</span><span class=kt>Int</span>, <span class=kt>K</span><span class=o>)</span>, <span class=kt>V</span><span class=o>)]</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=n>pos</span> <span class=k>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>def</span> <span class=n>hasNext</span><span class=k>:</span> <span class=kt>Boolean</span> <span class=o>=</span> <span class=n>pos</span> <span class=o>&lt;</span> <span class=n>curSize</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>def</span> <span class=n>next</span><span class=o>()</span><span class=k>:</span> <span class=o>((</span><span class=kt>Int</span><span class=o>,</span> <span class=kt>K</span><span class=o>),</span> <span class=n>V</span><span class=o>)</span> <span class=k>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(!</span><span class=n>hasNext</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=nc>NoSuchElementException</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=k>val</span> <span class=n>pair</span> <span class=k>=</span> <span class=o>(</span><span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[(</span><span class=kt>Int</span>, <span class=kt>K</span><span class=o>)],</span> <span class=n>data</span><span class=o>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pos</span> <span class=o>+</span> <span class=mi>1</span><span class=o>).</span><span class=n>asInstanceOf</span><span class=o>[</span><span class=kt>V</span><span class=o>])</span>
</span></span><span class=line><span class=cl>      <span class=n>pos</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=n>pair</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><p>PartitionedPariBuffer本质上是一个基于内存+磁盘的Array，随着数据添加，不断的扩容，但到达内存限制时，就将Array中的数据按照partitionId或者partitionId+Key进行排序，然后spill到磁盘上，该过程可以进行多次，最后对内存中和磁盘上的数据进行全局排序，输出或者提供给下一个操作。</p><h3 id=externalsorter>ExternalSorter</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-scala"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=k>private</span><span class=o>[</span><span class=kt>spark</span><span class=o>]</span> <span class=k>class</span> <span class=nc>ExternalSorter</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span>, <span class=kt>C</span><span class=o>](</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=k>:</span> <span class=kt>TaskContext</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>aggregator</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>Aggregator</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>V</span>, <span class=kt>C</span><span class=o>]]</span> <span class=k>=</span> <span class=nc>None</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>partitioner</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>Partitioner</span><span class=o>]</span> <span class=k>=</span> <span class=nc>None</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ordering</span><span class=k>:</span> <span class=kt>Option</span><span class=o>[</span><span class=kt>Ordering</span><span class=o>[</span><span class=kt>K</span><span class=o>]]</span> <span class=k>=</span> <span class=nc>None</span><span class=o>,</span>
</span></span><span class=line><span class=cl>    <span class=n>serializer</span><span class=k>:</span> <span class=kt>Serializer</span> <span class=o>=</span> <span class=nc>SparkEnv</span><span class=o>.</span><span class=n>get</span><span class=o>.</span><span class=n>serializer</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=k>extends</span> <span class=nc>Spillable</span><span class=o>[</span><span class=kt>WritablePartitionedPairCollection</span><span class=o>[</span><span class=kt>K</span>, <span class=kt>C</span><span class=o>]](</span><span class=n>context</span><span class=o>.</span><span class=n>taskMemoryManager</span><span class=o>())</span>
</span></span><span class=line><span class=cl>  <span class=k>with</span> <span class=nc>Logging</span> <span class=k>with</span> <span class=nc>ShuffleChecksumSupport</span> <span class=o>{</span></span></span></code></pre></div></div><p>字段：</p><p>aggregator: Option[Aggregator[K, V, C]] 可选的聚合函数</p><p>partitioner: 分区</p><p>ordering： Option[Ordering[K]] 可选的排序</p><p>如果需要聚合，使用<code>PartitionedAppendOnlyMap</code>作为内存中的数据结构（类似于HashMap），否则使用<code>PartitionedPairBuffer</code>作为内存数据结构（类似于动态数组）。</p><p>由于需要分区，所以不管Key需不需要排序，都需要按照partitionId进行排序，然后才能写入map out writer。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2025-06-01</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/posts/spark_shuffle/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on X" data-sharer=x data-url=http://example.org/posts/spark_shuffle/ data-title="Spark Shuffle机制" data-hashtags=Spark><i class="fab fa-x-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Threads" data-sharer=threads data-url=http://example.org/posts/spark_shuffle/ data-title="Spark Shuffle机制"><i class="fab fa-threads fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=http://example.org/posts/spark_shuffle/ data-hashtag=Spark><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=http://example.org/posts/spark_shuffle/ data-title="Spark Shuffle机制"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=http://example.org/posts/spark_shuffle/ data-title="Spark Shuffle机制"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@14.9.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=http://example.org/posts/spark_shuffle/ data-title="Spark Shuffle机制"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Diaspora" data-sharer=diaspora data-url=http://example.org/posts/spark_shuffle/ data-title="Spark Shuffle机制" data-description><i class="fab fa-diaspora fa-fw" aria-hidden=true></i></a><a href="https://t.me/share/url?url=http%3a%2f%2fexample.org%2fposts%2fspark_shuffle%2f&amp;text=Spark%20Shuffle%e6%9c%ba%e5%88%b6" target=_blank title="Share on Telegram"><i class="fab fa-telegram fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/spark/>Spark</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/java-concurrenthashmap/ class=prev rel=prev title="Java ConcurrentHashMap"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Java ConcurrentHashMap</a>
<a href=/posts/spark_job_execution/ class=next rel=next title="Spark Job执行流程">Spark Job执行流程<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=utterances class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.140.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.1-DEV"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>xxxx</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a></div><div id=fixed-buttons-hidden><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.2/sharer.min.js></script><script>window.config={comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"ShadowUnderMoon/ShadowUnderMoon.github.io"}},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:50,type:"lunr"}}</script><script src=/js/theme.min.js></script></body></html>